*边学边翻译，督促自己不能落下，同时也留点记忆*

# <center>**第十章 信号处理**</center> 

***
&nbsp;&nbsp;&nbsp;&nbsp;在图形学中，我们经常处理连续变量的函数:图像是您看到的第一个例子，但随着您继续探索图形学，您将遇到更多的例子。由于连续函数的性质，它们不能在计算机上直接表示出来;我们必须用有限的位数来表示它们。表示连续函数的一种最有用的方法是使用函数的样本:只需将函数的值存储在许多不同的点上，并在需要时重新构造中间的值。
&nbsp;&nbsp;&nbsp;&nbsp;您现在已经熟悉了使用二维像素网格表示图像的思想——因此您已经看到了采样表示!想象一下由数码相机捕捉到的图像:由相机镜头形成的场景的实际图像是图像平面上位置的连续函数，而相机将该函数转换为二维样本网格。从数学上讲，相机将一个R2→C类型的函数(其中C是颜色集合)转换为一个二维的颜色样本数组，还是一个Z类型的函数$Z^2->c$。
&nbsp;&nbsp;&nbsp;&nbsp;另一个样本表示的例子是2D数字化平板，如平板电脑的屏幕或艺术家使用的单独的笔平板。在这种情况下，原始函数是触控笔的运动，这是一个时变的2D位置，或者是一个类型为R→R2的函数。数字化仪在多个时间点测量触控笔的位置，从而得到一个2D坐标序列，或一个Z→R2类型的函数。动作捕捉系统也做同样的事情:对于附着在演员身上的一种特殊标记:它将标记的3D位置随着时间的推移(R→R3)，并将其转化为一系列瞬时位置测量(Z→R3)
&nbsp;&nbsp;&nbsp;&nbsp;在维数上，用于非侵入性检查人体内部的医用CT扫描仪，测量密度作为体内位置的函数。扫描仪的输出是密度值的3D网格:它将身体的密度(R3 R)转换为实数(ZR)的3D数组。
&nbsp;&nbsp;&nbsp;&nbsp;这些例子看起来不同，但实际上它们都可以用完全相同的数学方法来处理。在所有情况下，一个函数都是在一个或多个维度的晶格点上采样的，在所有情况下，我们都需要能够从样本数组中重建原始的连续函数。
&nbsp;&nbsp;&nbsp;&nbsp;从二维图像的例子来看，似乎像素就足够了，一旦相机将图像离散化，我们就再也不需要考虑连续函数了。但如果我们想让屏幕上的图像变大或变小，特别是通过离子整数比例因子，该怎么办呢?事实证明，最简单的算法执行得很糟糕，引入了被称为混叠的明显视觉假象。解释混叠发生的原因和理解如何防止它需要抽样理论的数学。由此产生的算法相当简单，但它们背后的推理和使它们运行良好的细节可能是微妙的。
&nbsp;&nbsp;&nbsp;&nbsp;在计算机中表示连续函数，当然不是图形所特有的;采样和重建的想法也不是。采样表示被用于从数字音频到计算物理的应用，而图形只是相关算法和数学的一个(绝不是第一个)用户。关于如何进行采样和重建的基本事实早在20世纪20年代就已经在通信领域为人所知，并在20世纪40年代以我们使用的完全相同的形式陈述出来(Shannon & Weaver, 1964)
&nbsp;&nbsp;&nbsp;&nbsp;本章首先用数字音频的一维具体例子来总结采样和重构。然后，我们继续介绍在一维和二维采样和重建的基础数学和算法。最后，我们深入到频域视点的细节，它为这些算法的行为提供了许多见解。

***
### 10.1数字音频:一维采样
&nbsp;&nbsp;&nbsp;&nbsp;虽然抽样表示在电信领域已使用多年，但在过去十年中音频数字录音的使用增加之后，1982年推出的光盘是抽样的第一个明显的消费者应用。
&nbsp;&nbsp;&nbsp;&nbsp;在录音过程中，麦克风将空气中以压力波的形式存在的声音转换为时变电压，这相当于对麦克风所在点的空气压力变化的测量。这种电信号需要以某种方式储存起来，以便在以后的时间里回放并发送到扬声器中，扬声器通过移动与电压同步的膜片将电压转换回压力波。
&nbsp;&nbsp;&nbsp;&nbsp;记录音频信号的数字方法(图10.1)使用采样:一个模数转换器(A/D转换器，或ADC)每秒测量数千次电压，生成一个整数流，可以很容易地存储在任何数量的媒体上，比如录音棚计算机上的磁盘，或传输到另一个位置，比如便携式音频播放器中的内存。在回放时，数据以适当的速率读出并发送到数模转换器(D/ a转换器，或DAC)。DAC根据它接收到的数字产生一个电压，并且，只要我们取足够多的样本来恰当地表示电压的变化，得到的电信号在所有实际用途上都与输入完全相同。
&nbsp;&nbsp;&nbsp;&nbsp;结果表明，每秒需要的样本数量取决于我们试图记录的声音的高音。如果我们试图录制短笛或铙钹，一个适合于复制弦乐低音或踢鼓的采样率就会产生奇怪的结果;但在较高的采样率下，这些声音可以很好地再现。为了避免这些采样不足的工件，数字音频记录器对ADC的输入进行过滤，以去除可能导致问题的高频。
&nbsp;&nbsp;&nbsp;&nbsp;另一类问题出现在输出端。DAC产生的电压在新样本进入时发生变化，但在下一个样本进入前保持恒定，产生阶梯形图。这些台阶就像噪音一样，增加了一种高频的、依赖于信号的嗡嗡声。为了消除这个重构工件，数字音频播放器过滤DAC的输出以平滑波形。
#### 10.1.1采样伪影和混叠
&nbsp;&nbsp;&nbsp;&nbsp;数字音频记录链可以作为图形中发生的采样和重建过程的具体模型。图形中的图像或其他采样信号也会出现同样的欠采样和重构伪象，解决方法是相同的:采样前先滤波，重建时再滤波。
&nbsp;&nbsp;&nbsp;&nbsp;图10.2中显示了采样频率过低可能产生的伪影的一个具体示例。在这里，我们使用两种不同的采样频率对一个简单的正弦波进行采样:顶部每周期10.8个采样和底部每循环1.2个样品。较高的采样率产生的一组样本显然很好地捕获了信号，但较低采样率产生的样本与低频正弦波的样本难以区分——事实上，面对这组样本，低频正弦波似乎更有可能被解释。
&nbsp;&nbsp;&nbsp;&nbsp;一旦采样完成，就不可能知道两个信号中哪个是快正弦波，哪个是慢正弦波——是原始的，因此，没有一种方法可以正确地重建两种情况下的信号。因为高频信号“假装”成低频信号，这种现象被称为混叠。
&nbsp;&nbsp;&nbsp;&nbsp;当采样和重建中的缺陷导致伪影出现在惊人的频率时，混叠就会出现。在音频中，混叠以听起来奇怪的额外音调的形式出现——以10千赫的铃声在以8千赫的频率采样后，就变成了6千赫的音调。在图像中，混叠通常以moiré模式的形式出现，这是示例网格与图像中的常规特征相互作用的结果，例如图10.34中的百叶窗。
&nbsp;&nbsp;&nbsp;&nbsp;合成图像中混叠的另一个例子是我们所熟悉的直线上的台阶，这是用黑白像素渲染的(图10.34)。这是一个小尺度特征(线条的锋利边缘)在不同尺度上创造工件的例子(对于浅坡度的线条，楼梯的台阶非常长)。
&nbsp;&nbsp;&nbsp;&nbsp;采样和重构的基本问题可以简单地根据特征的过小或过大来理解，但一些更定量的问题则很难回答:
* 什么样的抽样率足够高以确保良好的结果?
* 什么样的滤波器适合于采样和重建?
* 需要什么程度的平滑来避免混叠?
&nbsp;&nbsp;&nbsp;&nbsp;这些问题的确切答案必须等到我们在第10.5节完整地发展了理论之后。

***
### 10.2 卷积
&nbsp;&nbsp;&nbsp;&nbsp;在讨论采样和重构算法之前，我们首先考察它们所基于的数学概念——卷积。卷积是一个简单的数学概念，它是用于采样、滤波和重构的算法的基础。这也是我们在本章中分析这些算法的基础。
&nbsp;&nbsp;&nbsp;&nbsp;卷积是一种对函数的运算:它取两个函数并将它们组合起来生成一个新函数。在本书中，卷积算子用星号表示:对函数f和g进行卷积的结果是f *g。我们说f与g卷积，f * g是f与g的卷积。
&nbsp;&nbsp;&nbsp;&nbsp;卷积既可以应用于连续函数(函数f (x)为任何实参数z定义)，也可以应用于离散序列(函数a[i]仅为整数参数i定义)。它还可以应用于定义在一维、二维或高维域上的函数(即具有一个、两个或多个参数的函数)。我们将先从离散的，一维的情况开始，然后继续讲连续函数，二维和三维函数。
&nbsp;&nbsp;&nbsp;&nbsp;为了便于定义，我们通常假设函数的定义域是无限的，当然，在实际操作中它们必须在某个地方停止，并且我们必须以一种特殊的方式处理端点。
#### 10.2.1移动平均线
&nbsp;&nbsp;&nbsp;&nbsp;为了得到卷积的基本图像，考虑使用移动平均平滑ID函数的例子(图10.3)。为了得到任意点的平滑值，我们计算函数在每个方向上延伸距离为r的范围内的平均值。距离r，称为平滑操作的半径，是一个控制平滑发生多少的参数。
&nbsp;&nbsp;&nbsp;&nbsp;对于离散函数或连续函数，我们可以用数学方法表述这个概念。如果我们平滑一个连续函数g(z)，平均意味着对g在区间上积分然后除以区间的长度:
h（x）
&nbsp;&nbsp;&nbsp;&nbsp;另一方面，如果我们平滑一个离散函数a[i]，平均意味着对一系列指标a求和，然后除以值的数量:
C[i]
&nbsp;&nbsp;&nbsp;&nbsp;在每一种情况下，选择归一化常数，这样如果我们平滑一个常数函数，结果将是相同的函数。
&nbsp;&nbsp;&nbsp;&nbsp;移动平均的概念是卷积的本质;唯一的区别是，在卷积中，移动平均是加权平均。
#### 10.2.2 离散卷积
&nbsp;&nbsp;&nbsp;&nbsp;我们将从卷积最具体的情况开始:将一个离散序列a[i]与另一个离散序列b[i]进行卷积。结果是一个离散序列（sd） 。这个过程就像用移动平均线平滑a，但是我们没有对距离r内的所有样本进行同等的加权，而是使用第二个序列b对每个样本进行加权(图10.4)。值b[i- j]给出了样本在j位置的权重，它距离我们计算卷积的指标i的距离为i- j。下面是(a*b)的定义，用公式表示:
(a*b)[] = Da[i]b[i - j]。
(10.2)
&nbsp;&nbsp;&nbsp;&nbsp;通过省略j的边界，我们表示这个和在所有整数上运行(即，从-o到+oo)。图10.4说明了如何计算一个输出样例，使用b =[…， 0, 1, 4, 6, 4, 1,0，…也就是说，b[0] =， b[t1] = 16
等。
&nbsp;&nbsp;&nbsp;&nbsp;在图形中，这两个函数中的一个通常具有有限的支持(如图10.4中的示例所示)，这意味着它只在有限的参数值区间内是非零的。如果我们假设b的支持度是有限的，那么存在某个半径r使得b[k]在(k > r)时= 0。在这种情况下，我们可以写出这个和卷积过滤器
&nbsp;&nbsp;&nbsp;&nbsp;卷积很重要，因为我们可以用它来进行滤波。回头看看我们的第一个滤波例子，移动平均，我们现在可以把平滑操作重新解释为与特定序列的卷积。当我们在有限的指数范围内计算平均值时，这就相当于对范围内的所有点进行相同的加权，对其余的点进行零加权。这种过滤器在非零区间内具有恒定值，称为框过滤器(因为如果绘制它的图形，它看起来像一个矩形—参见图10.5)。对于半径为r的箱形滤波器，权值为1/(2r + 1):
1
-r < k < r,否则。
&nbsp;&nbsp;&nbsp;&nbsp;如果将这个filter代入(10.2)式中，会发现它简化为(10.1)式中的移动平均。
&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，卷积滤波器通常被设计成它们的和为1。这样，它们就不会影响信号的整体水平。
&nbsp;&nbsp;&nbsp;&nbsp;例20(盒子和阶跃的卷积)对于一个简单的滤波例子，设信号为阶跃函数
卷积a和b的结果是什么?在一个特定的索引i处，如图10.6所示，结果是阶跃函数在i-2到i + 2范围内的平均值。如果i <-2，我们对所有的0求平均，结果为0。如果i > 2，我们求所有1的平均值，结果是1。中间有i + 3个，结果是t3。输出是一个线性斜坡，从0到1除以5个样本:[…， 0,0,1,2,3,4,5,5，。
##### 卷积的属性
&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们写卷积的方式，似乎是一个非对称操作a是我们要平滑的序列，b提供权值。但是卷积的一个很好的性质是它实际上没有任何区别滤波器和信号是可以互换的。要知道这一点，只需重新考虑(10.2)式中的和，其中指标从过滤器b的原点开始计数，
而不是从a的原点开始，也就是说，我们用i - k替换j，变量替换的结果是Cb[k]a[i - k]
&nbsp;&nbsp;&nbsp;&nbsp;这与式(10.2)完全相同，但a作为滤波器，b作为信号。对于任意序列a和b， (a*b) = (b* a)我们说卷积是一个交换运算。
&nbsp;&nbsp;&nbsp;&nbsp;更一般地说，卷积是一种“类似于乘法”的运算。就像数字或函数的乘法或加法一样，参数的顺序和括号的位置都不会影响结果。此外，卷积和加法的关系和乘法的关系是一样的。准确地说，卷积是交换的和结合的，它是加法的分配的。
&nbsp;&nbsp;&nbsp;&nbsp;如果我们把卷积想象成乘法，这些性质是非常自然的，而且它们很容易掌握因为它们可以帮助我们在计算卷积之前简化卷积，从而节省工作量。例如，假设我们想取一个序列a，并将其与三个过滤器(bi、b2和bs)进行卷积——也就是说，我们想要((a*b1) *b2) * bs。如果序列很长，而滤波器很短(也就是说，它们的半径很小)，首先将三个滤波器卷积在一起(计算bi *b2 * bs)，最后将结果与信号卷积，计算a * (bi *b2 * b3)，这要快得多，从结合度我们知道，结果是相同的。
&nbsp;&nbsp;&nbsp;&nbsp;一个非常简单的滤波器可以作为离散卷积的恒等式:它是半径为0的离散滤波器，或者序列d[i] =…，0, 0, 1,0,0，…(图10.7)。如果我们将d与信号a卷积，在
总结:
&nbsp;&nbsp;&nbsp;&nbsp;显然，a与d的卷积又得到了a。序列d被称为离散脉冲。它有时在表示滤波器时很有用:例如，用滤波器b平滑信号a，然后从原始信号中减去该信号的过程可以用滤波器d -b表示为一个单卷积:
C = a- a*b = a*d - a*b = a* (d - b)。
#### 10.2.3卷积作为移位滤波器的和
&nbsp;&nbsp;&nbsp;&nbsp;还有一种完全相同的解释式(10.2)的方法。每次只看一个axb的样本，就会得到我们已经见过的加权平均解释。但是如果我们省略了[i]，我们可以把和看作是整个序列的相加。要做到这一点需要一个符号:如果b是一个序列，那么向右移动j位的同一序列称为$b_{->j}$(图10.8):
$$
b_{->j}[i] = b[i-j]
$$
&nbsp;&nbsp;&nbsp;&nbsp;然后，我们可以将式(10.2)写成关于整个序列(axb)的语句，而不是逐个元素的语句:
$$
(a * b) = \sum_ja[j]b_{->j}
$$
&nbsp;&nbsp;&nbsp;&nbsp;从这个角度看，卷积是b的移位副本的和，用a的分量加权(图10.9)。由于交换性，我们可以选择a或b作为滤波器;如果我们选择b，那么我们就是在为输入中的每个样本加一个滤波器的副本。
#### 10.2.4连续函数卷积
&nbsp;&nbsp;&nbsp;&nbsp;虽然离散序列确实是我们在计算机程序中实际使用的，但这些采样序列应该表示连续函数，通常我们需要对连续函数进行数学推理，以找出该怎么做。因此，定义连续函数之间以及连续函数与离散函数之间的卷积是很有用的。
&nbsp;&nbsp;&nbsp;&nbsp;两个连续函数的卷积是对式(10.2)的明显推广，用积分代替和:
$$
(f*g(x)) =\int_{-\infty}^{+\infty}f(t)g(x-t)dt 
$$
&nbsp;&nbsp;&nbsp;&nbsp;解释这个定义的一种方法是f和g的卷积，在辐角z处的值，是两个函数的乘积曲线下的面积当我们移动g使g(O)和f(t)对齐后。就像在离散的情况下，卷积是一个移动平均，滤波器提供平均值的权重(见图10.10)。
&nbsp;&nbsp;&nbsp;&nbsp;像离散卷积一样，连续函数的卷积是交换的和结合律的，它是加法的分配律。同样，与离散情况一样，连续卷积可以被看作是滤波器副本的和，而不是加权平均值的计算。除了，在这种情况下，过滤器g有无限多个副本:
$$
(f*g) =\int_{-\infty}^{+\infty}f(t)g_{->t}dt 
$$
如(两个盒函数的卷积)设f是一个盒函数:
$$ f=\left\{
\begin{matrix}
&1  &-\frac{1}{2}<=x\frac{1}{2}, \\
&0  &Otherwise
\end{matrix}
\right.
$$
那么f * f是什么?定义(式10.3)给出
$$
(f*f(x)) =\int_{-\infty}^{+\infty}f(t)f(x-t)dt 
$$
&nbsp;&nbsp;&nbsp;&nbsp;图10.11显示了该积分的两种情况。当r <-1或r > 1时，两个盒子可能没有重叠;在本例中，结果为零。
当-1 <r< 1时，重叠依赖于两个盒子之间的分离，即|r);结果是1 - |a。所以
$$
(f*f)(x)=\left\{
\begin{matrix}
&1-|x|  &-1<x<1, \\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;这个函数称为tent函数，是另一个常见的过滤器(参见10.3.1节)。
##### 狄拉克函数
&nbsp;&nbsp;&nbsp;&nbsp;在离散卷积中，我们看到离散脉冲d充当恒等函数:$d*a = \alpha$。在连续卷积中，还有一个恒等函数，称为狄拉克脉冲或狄拉克函数，记为(x)。
&nbsp;&nbsp;&nbsp;&nbsp;直观地看，函数是一个非常窄、非常高的尖刺，它的宽度无穷小，但面积仍然等于1(图10.12)。函数的关键定义性质是，用一个函数乘以它，正好选出在0处的值:
$$
\int_{-\infty}^{+\infty}g(t)f(x)dx  = f(0)
$$
&nbsp;&nbsp;&nbsp;&nbsp;函数在0处没有定义良好的值(您可以将其值松散地认为是+oo)，但对于所有z +0，它的值(x)都是= 0。
&nbsp;&nbsp;&nbsp;&nbsp;从这个挑选出单值的性质，可以得出脉冲函数是连续卷积的恒等式(图10.13)，因为将s与任意函数f进行卷积得到
$$
(\delta*f)(x) = \int_{-\infty}^{+\infty}\delta(t)f(x-t)dt = f(x) 
$$
&nbsp;&nbsp;&nbsp;&nbsp;所以* f = f(因为交换性f *也= f)
#### 10.2.5 离散连续卷积
&nbsp;&nbsp;&nbsp;&nbsp;有两种方法可以连接离散的和连续的世界。一种是抽样:我们将一个连续函数转换为一个离散函数，方法是写下函数在所有整数参数处的值，而忽略其他参数。给定一个连续函数f(z)，我们可以对其采样，将其转换为一个离散序列a[i]:
$$
a[i]=f(i)
$$
&nbsp;&nbsp;&nbsp;&nbsp;反过来，从一个离散函数，或序列，到一个连续函数，叫做重构。这是用另一种形式的卷积来完成的，离散-连续形式。在本例中，我们用连续滤波器f(x)对离散序列a[i]进行滤波:
$$
(a*f)(x) = \sum_ia[i]f(x-i)
$$
&nbsp;&nbsp;&nbsp;&nbsp;重构函数a*f在r处的值是i在z附近值的样本a[i]的加权和(图10.14)。权值来自滤波器f。
&nbsp;&nbsp;&nbsp;&nbsp;在一组间隔为一个单位的点上求值。例如，如果r = 5.3, f的半径为2，则f在1.3、0.3、-0.7和-1.7处求值。注意，对于离散-连续卷积，我们通常先写序列，然后写过滤器，这样和是对整数的。
&nbsp;&nbsp;&nbsp;&nbsp;和离散卷积一样，如果我们知道滤波器的半径r，我们可以在和上加上边界，消除所有r和i之差的点
r:
$$
    (a*f)(x) = \sum_{i=\lfloor x-r\rfloor}^{\lceil x + r\rceil}ia[i]f(x-i)
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，如果一个点正好落在r到r的距离上(例如，如果z - r被证明是一个整数)，它将被排除在和之外。这与离散的情况相反，在离散的情况中，我们包含了在i -r处的点。
&nbsp;&nbsp;&nbsp;&nbsp;用代码表示:
~~~
    function reconstruct(sequence a,filter f, real x)
        s = 0
        r = f.radius
        for i = [x - r] to [x + r] do
            s = s + a[i]f(x - i)
    return s
~~~
&nbsp;&nbsp;&nbsp;&nbsp;与其他形式的卷积一样，离散-连续卷积可以被视为对移位的滤波器副本的求和(图10.15):
$$
(a*f) = \sum_{i}a[i]f_{\to t}
$$
&nbsp;&nbsp;&nbsp;&nbsp;离散连续卷积与样条曲线密切相关。对于均匀样条(例如均匀b样条)，样条的参数化曲线恰好是样条基函数与控制点序列的卷积(见15.6.2节)。
##### 10.2.6多维卷积
&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们所说的关于采样和重建的一切都是一维的:只有一个变量z或一个序列索引i。然而，在图形学中采样和重建的许多重要应用都应用于二维函数——特别是二维图像。幸运的是，将采样算法和理论从ID推广到2D、3D以及更远的地方在概念上非常简单。
&nbsp;&nbsp;&nbsp;&nbsp;从离散卷积的定义开始，我们可以将其推广到二维，将和变为双和:
$$
(a*b)[i,j] = \sum_{i^`}\sum_{j^`}a[i^`,j^`]b[i-i^`,j-j^`]
$$
&nbsp;&nbsp;&nbsp;&nbsp;如果b是一个半径为r的有限支持的过滤器(即它有(2r + 1)2个值)，那么我们可以写出这个有边界的和(图10.16):
$$
(a*b)[i,j] = \sum_{i^`=i-r}^{i+r}\sum_{j^`=j-r}^{j+r}a[i^`,j^`]b[i-i^`,j-j^`]
$$
可以用代码表示:
(图10.18)卷积:
~~~
    function convolve2d(sequence2d a,filter2d b, int i ,int j)
        s = 0
        r = b.randius

        for i' = i-r to i+r  do
            for j' = j-r to j+r  do
            s = s + a[i'][j']b[i-i'][j=j']
    return s
~~~
&nbsp;&nbsp;&nbsp;&nbsp;这个定义可以用与ID情况相同的方式来解释:每个输出样本都是输入区域的加权平均值，使用2D滤波器作为“掩码”来确定每个样本在平均值中的权重。
&nbsp;&nbsp;&nbsp;&nbsp;继续泛化，我们还可以在2D中编写连续-连续(图10.17)和离散-连续
&nbsp;&nbsp;&nbsp;&nbsp;在每种情况下，在某一特定点处的结果是该点附近输入的加权平均值。对于连续-连续的情况，它是一个以该点为中心的区域的加权积分，而对于离散-连续的情况，它是落在该点附近的所有样本的加权平均值。
$$
(f*g)(x,y) =\int \int f(x',y')g(x-x',y-y') dx'dy';\\
(a*g)(i,j) = \sum_{i}\sum_{j}a[i,j]f(x-i,y-j)
$$
&nbsp;&nbsp;&nbsp;&nbsp;一旦我们从1D到2D，我们就应该很清楚如何进一步推广到3D甚至更高的维度。

***
### 10.3卷积过滤器
&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经有了卷积的机制，让我们检查一些在图形中常用的特殊滤波器。
&nbsp;&nbsp;&nbsp;&nbsp;下面的每个过滤器都有一个自然半径，当样本间隔为一个单位时，该半径是用于采样或重建的默认大小。在本节中，过滤器是在这个自然大小下定义的:例如，盒式过滤器的自然半径是s，三次过滤器的自然半径是2。我们还安排每个滤波器积分为1:Jo f(x)da = 1，如所要求的
= 0,在不改变信号平均值的情况下进行采样和重建。
&nbsp;&nbsp;&nbsp;&nbsp;正如我们将在第10.4.3节中看到的，一些应用程序需要不同大小的过滤器，这些过滤器可以通过缩放基本过滤器获得。对于过滤器f (x)，我们可以定义一个版本的刻度
$$
f_s(x)=\frac{f(x/s)}{s}.
$$
&nbsp;&nbsp;&nbsp;&nbsp;滤波器在水平方向被拉伸s倍，然后在垂直方向被压缩一个倍，因此它的面积不变。一个过滤器的自然半径为r，在刻度s下使用，其支持半径为sr(见图10.20)。
#### 10.3.1卷积滤波器库
##### 盒子过滤器
&nbsp;&nbsp;&nbsp;&nbsp;箱形滤波器(图10.19)是一个分段常数函数，其积分等于1。作为一个离散滤波器，它可以写成
$$
a_{box,r}[i]=\left\{
\begin{matrix}
&1/{2r+1} &|i|\leq r, \\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，为了对称，我们包括两个端点。
&nbsp;&nbsp;&nbsp;&nbsp;作为一个连续的过滤器，我们写
$$
f_{box,r}(x)=\left\{
\begin{matrix}
&1/2r &-r\leq x< r, \\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;在本例中，我们排除了一个端点，这使得半径为0.5的方框可用作重构过滤器边界的情况很重要，所以对于这个特殊的过滤器，我们需要注意它们。我们用fbox表示r的自然半径=
##### 帐篷过滤器
&nbsp;&nbsp;&nbsp;&nbsp;帐篷或线性过滤器(图10.20)是一个连续的分段线性函数:
$$
f_{tent}(x)=\left\{
\begin{matrix}
&1-|x| &|x|< r, \\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;它的自然半径是1。对于至少为CO的过滤器，比如这个过滤器(即值中没有突然的跳跃，就像方框一样)，我们不再需要分离离散过滤器和连续过滤器的定义:离散过滤器就是在整数处采样的连续过滤器。
##### 高斯滤波器
&nbsp;&nbsp;&nbsp;&nbsp;高斯函数(图10.21)，又称正态分布，是理论和实践中重要的滤波器。随着本章的继续，我们将看到更多的特殊属性:
$$
f_g,\sigma(x)=\frac{1}{\sigma\sqrt{2\Pi}}e^{-\frac{-x^2}{2\sigma^2}}
$$
&nbsp;&nbsp;&nbsp;&nbsp;参数o称为标准偏差。高斯滤波器是一个很好的采样滤波器，因为它非常平滑;我们将在第10.5节更精确地说明这一点。
&nbsp;&nbsp;&nbsp;&nbsp;高斯滤波器没有任何特定的自然半径;对于o的范围，它是一个有用的采样滤波器。高斯函数也没有一个有限的支持半径，尽管由于指数衰减，它的值很快变得小到可以忽略。在必要的时候，我们可以通过将函数在半径r以外的地方设为零来修剪函数的尾部，从而得到修剪后的高斯函数。这意味着过滤器的宽度和自然半径可以根据应用程序的不同而变化，一个缩放s的裁剪高斯与一个标准偏差so和半径sr的未缩放的裁剪高斯是相同的。在实践中处理这个问题的最佳方法是让o和r被设置为过滤器的属性，在指定过滤器时固定，然后在应用过滤器时像任何其他过滤器一样缩放过滤器。
##### b样条三次滤波器
&nbsp;&nbsp;&nbsp;&nbsp;许多滤波器被定义为分段多项式，通常使用四段(自然半径为2)的三次滤波器作为重构滤波器。其中一个这样的滤波器被称为b样条滤波器(图10.22)，因为它的起源是样条曲线的混合函数(见第15章):
$$
f_{B}(x)=\frac{1}{6}\left\{
\begin{matrix}
&-3(1-|x|)^3+3(1-|x|) ^2+3(1-|x|)+1 &-1\leq x\leq 1, \\
&(2-|x|)^3  &1\leq |x|\leq 2 \\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;在分段三次曲线中，b样条曲线是特殊的，因为它有连续的一阶和二阶导数，也就是说，它是C2。定义这个过滤器更简洁的方法是fB =fbox * fbor * foox * fbox;证明上面的长形式是等价的是一个很好的卷积练习(见练习3)。
##### 卡特穆尔-罗姆立方滤波器
&nbsp;&nbsp;&nbsp;&nbsp;另一个以样条命名的分段三次滤波器，Catmull Rom滤波器(图10.23)，在r = -2， -1, 1，和2时的值为零，这意味着它将插值样本作为重构滤波器(章节10.3.2):
$$
fc(x)=\frac{1}{6}
\begin{cases}
&-3(1-|x|)^3+4(1-|x|) ^2+(1-|x|) &-1\leq x\leq 1, \\
&(2-|x|)^3 -(2-|x|)^2 &1\leq |x|\leq 2 \\
&0  &Otherwise
\end{cases}
$$
##### 米切尔-尼特拉瓦利立方滤波器
&nbsp;&nbsp;&nbsp;&nbsp;对于重采样图像这一非常重要的应用，Mitchell和Netravali(1988)对三次滤波器进行了研究，并推荐介于前两种滤波器中间的一种作为最佳的全能选择(图10.24)。它只是前两个过滤器的加权组合
$$
fm(x)=\frac{1}{3}f_B(x)+\cfrac{2}{3}f_C(x) \\
=\frac{1}{18}
\begin{cases}
&-21(1-|x|)^3+27(1-|x|) ^2+9(1-|x|)+1 &-1\leq x\leq 1, \\
&7(2-|x|)^3 -6(2-|x|)^2 &1\leq |x|\leq 2 \\
&0  &Otherwise
\end{cases}
$$
#### 10.3.2过滤器属性
&nbsp;&nbsp;&nbsp;&nbsp;过滤器有一些传统的术语，我们用它们来描述过滤器并相互比较。
&nbsp;&nbsp;&nbsp;&nbsp;滤波器的脉冲响应是函数的另一种叫法:它是滤波器对包含脉冲的信号的响应(回想一下，与脉冲卷积会返回滤波器)。
&nbsp;&nbsp;&nbsp;&nbsp;连续滤波器是插值的如果，当它被用来重建样品重建一个来自dis的连续函数信号克里特序列，由此产生的func土豆
Tion取的值恰好是和这权重样本点上的样本
位，导致函数值低于O，超过1(图10.26)。
&nbsp;&nbsp;&nbsp;&nbsp;连续滤波器是无纹波的，当它被用作重构滤波器时，它将作为常数函数重构常量序列(图10.27)。这相当于要求任何整数空间网格上的过滤器和为1:对于所有r, Df(r+i) =1。
&nbsp;&nbsp;&nbsp;&nbsp;第10.3.1节中的所有过滤器在其自然半径处都是无波纹的，除了高斯分布，但当它们在非整数尺度下使用时，它们都不一定是无波纹的。如果需要消除离散-连续卷积中的纹波，很容易做到:将每个计算样本除以用于计算它的权值的和:
sdkjlsdjflkjkflkdsj
&nbsp;&nbsp;&nbsp;&nbsp;这个表达式仍然可以解释为a和滤波器f之间的卷积(见练习6)。
&nbsp;&nbsp;&nbsp;&nbsp;连续滤波器具有一定的连续性，这是最高阶导数，在任何地方都有定义。一个过滤器，像盒子过滤器，它的值有突然的跳跃，根本不是连续的。一个连续但有尖角(一阶导数不连续)的滤波器，如帐篷滤波器，其连续阶数为零，我们称其为CO。一个有连续导数(无尖角)的滤波器，如前一节中的分段立方滤波器，为C';如果它的二阶导数也是连续的，就像b样条滤波器一样，它是C2。滤波器的连续性顺序对于重构滤波器来说尤为重要，因为重构函数继承了滤波器的连续性。
##### 可分离的过滤器
&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们只讨论了1D卷积的滤波器，但对于图像和其他多维信号，我们也需要滤波器。一般来说，任何2D函数都可以是2D过滤器，有时这样定义它们是有用的。但是，在大多数情况下，我们可以根据我们已经看到的ID过滤器构建合适的2D(或高维)过滤器。
&nbsp;&nbsp;&nbsp;&nbsp;最有用的方法是使用可分离过滤器。可分离滤波器f2(z, y)在特定r和y处的值就是fi (ID滤波器)在z和y处的值的乘积:
$$
f_2(x,y) = f_1(x)f_1(y).
$$
&nbsp;&nbsp;&nbsp;&nbsp;类似地，对于离散滤波器，
$$
b_2[i,j] = b_1[i]b_1[j].
$$
&nbsp;&nbsp;&nbsp;&nbsp;任何通过f2的水平或垂直切片都是fi的缩放副本。f2的积分等于fi积分的平方，特别地，如果fi是归一化的，那么f2也是
如果我们为fi选择帐篷函数，得到的分段双线性函数(图10.28)为
$$
f_{2,tent}(x,y)=\left\{
\begin{matrix}
&(1-|x|)(1-|y|) &|x|< 1 and |y|<1\\
&0  &Otherwise
\end{matrix}
\right.
$$
&nbsp;&nbsp;&nbsp;&nbsp;沿着坐标轴的轮廓是帐篷函数，但是沿着对角线的轮廓是二次函数(例如，沿着正象限的z = y线，我们看到二次函数(1 - r)2)。
如果我们为fi选择高斯函数，得到的2D函数(图10.29)为
$$
f_{2,g}(x,y)=\frac{1}{2\pi}(e^{-x^2)}e^{-y^2/)})', \\
 = \frac{1}{2\pi}(e^{-(x^2+y^2)/2}),\\
 = \frac{1}{2\pi}e^{-r^2/2}
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，如果我们将一维高斯函数绕原点旋转以产生圆对称的函数，我们得到的函数是相同的(直到一个比例因子)
函数。同时圆对称和可分离的性质是高斯函数所特有的。沿着坐标轴的轮廓是高斯的，但是在离中心的任何偏移处，沿着任何方向的轮廓也是高斯的。
可分离过滤器相对于其他2D过滤器的关键优势在于执行效率。我们把a的定义代入到离散卷积的定义中
$$
(a*b_2)[i,j] = \sum_{i'}\sum_{j'}a[i',j']b_1[i-i']b_1[j-j'].
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意bi[i-i]不依赖于j'，可以从内部和中分解出来:
 
&nbsp;&nbsp;&nbsp;&nbsp;让我们把内部和缩写为S[i]:

&nbsp;&nbsp;&nbsp;&nbsp;有了这种形式的方程，我们可以首先对i'的每个值计算并存储S[i]，然后使用这些存储的值计算外部的和。乍一看，这似乎没什么了不起的，因为我们仍然要做与(2r + 1)2成正比的功来计算所有的内部和。然而，如果我们想计算多个点[i, j]处的值，情况就大不一样了。
&nbsp;&nbsp;&nbsp;&nbsp;假设我们需要计算a * b2在[2,2]和[3,2]处，bi的半径为2。检查10.5式，我们可以看到我们需要S[0]，..，S[4]来计算在[2,2]处的结果，我们需要S[1]，…， S[5]计算在[3,2]处的结果。因此，在可分离变量公式中，我们可以计算S的所有6个值并共享S[1]。S[4](图10.30)。
&nbsp;&nbsp;&nbsp;&nbsp;这种节省对大型过滤器具有重要意义。在一般情况下，使用半径为r的过滤器过滤图像需要计算每个像素(2r + 1)2个乘积，而使用相同大小的可分离过滤器过滤图像需要计算2(2r + 1)个乘积(以牺牲一些中间存储为代价)。这种从O(r2)到O(r)的渐近复杂度的变化使我们能够使用。算法如下：
~~~
function filterImage(image I, filter b)
    r = b.radius
    nx = I.width
    ny = I.height
    allocate storage array S[0 ... nx − 1]
    allocate image Iout[r ... nx − r − 1,r ... ny − r − 1]
    initialize S and Iout to all zero
        for j = r to ny − r − 1 do
            for i' = 0 to nx − 1 do
                S[i']=0
                for j' = j − r to j + r do
                S[i'] = S[int_'] + I[i', j']b[j − j']
        for i = r to nx − r − 1 do
            for i' = i − r to i + r do
                Iout[i, j] = Iout[i, j] + S[i']b[i − i']
    return Iout
~~~
&nbsp;&nbsp;&nbsp;&nbsp;为了简单起见，这个函数通过从输出图像的所有四个边去掉r个像素来避免所有的边界问题。在实践中，有各种处理边界的方法;参见10.4.3。

### 10.4 图像采样
&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们已经抽象地讨论了采样、滤波和重构，主要使用一维信号作为例子。但正如我们在本章开头所观察到的，信号处理在图形学中最重要和最常见的应用是采样图像。让我们仔细看看这一切是如何应用于图像的。
#### 10.4.1使用离散滤波器进行图像滤波
&nbsp;&nbsp;&nbsp;&nbsp;也许卷积最简单的应用是使用离散卷积处理图像。图像处理程序最广泛使用的一些特性是简单的卷积滤波器。图像的模糊可以通过与许多常见的低通滤波器卷积来实现，范围从方框到高斯(图10.31)。高斯滤镜产生非常平滑的模糊效果，通常用于此目的。
&nbsp;&nbsp;&nbsp;&nbsp;与模糊相反的是锐化，其中一种方法是使用“不锐化蒙版”程序:从模糊图像中减去a的一个分数，为避免修改所有的光照修改，需要做一个修正：
其中fg,o是宽度为o的高斯滤波器。使用离散脉冲d和卷积的分布特性，我们能够将整个过程写成一个单一的滤波器，它取决于模糊的宽度和锐化的程度(图10.32)。
另一个组合两个离散过滤器的例子是投影。这是通常采取一个模糊的，移动的副本的对象的轮廓创建一个柔和的阴影(图10.33)。我们可以将移位运算表示为带有偏心脉冲的卷积:
$$
f_{m,n}(i,j)=\left\{
\begin{matrix}
&1 &i=m and j=m, \\
&0  &Otherwise
\end{matrix}
\right.
$$
移动，然后模糊，通过与两个滤波器卷积来实现:
$$
\begin{aligned}
I_{shadow} &= (I * d_{m,n}) * f_{g,\sigma} \\
& = I* (d_{m,n}* f_{g,\gamma}) \\
& = I* f_{shadow} (m,n，\sigma)。
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;在这里，我们使用结合性将两个操作分组到一个具有三个参数的过滤器中。
#### 10.4.2图像采样中的抗锯齿
&nbsp;&nbsp;&nbsp;&nbsp;在图像合成中，我们经常需要对图像进行采样表示，我们有一个连续的数学公式(或者至少是一个程序，我们可以用来计算任意点的颜色，而不仅仅是整数像素位置的颜色)。射线追踪是一个常见的例子;更多关于射线追踪和反锯齿的具体方法在第4章。在信号处理的语言中，我们有一个连续的二维信号(图像)，我们需要在一个规则的二维晶格上采样。如果我们不采取任何特殊措施对图像进行采样，结果将显示各种别名工件(图10.34)。在图像的锋利边缘处，我们看到了被称为“锯齿状”的阶梯状伪影。在有重复模式的区域，我们看到称为摩尔纹的宽带。
&nbsp;&nbsp;&nbsp;&nbsp;这里的问题是，图像包含了太多的小尺度特征;我们需要在采样前通过过滤使其平滑。回顾式(10.3)中连续卷积的定义，我们需要在像素位置周围的区域内对图像进行平均，而不是只取单个点的值。具体的方法在第4章中讨论。像盒子这样的简单过滤器将改善锋利边缘的外观，但它仍然会产生一些moiré模式(图10.35)。高斯滤波器非常平滑，对于moiré模式更有效，但代价是总体上更加模糊。这两个例子说明了清晰度和混叠之间的权衡，这是选择抗混叠滤波器的基础。
#### 10.4.3重构和重采样
&nbsp;&nbsp;&nbsp;&nbsp;最常见的图像操作之一是重采样，其中仔细过滤是至关重要的，即改变采样率，或改变图像大小。
&nbsp;&nbsp;&nbsp;&nbsp;假设我们用数码相机拍摄了一张大小为3000 * 2000像素的图像，我们希望在只有1280 * 1024像素的显示器上显示它。为了使它适合，同时保持3:2的长宽比，我们需要重新采样到1278乘852像素。我们应该怎么做呢?
&nbsp;&nbsp;&nbsp;&nbsp;解决这个问题的一种方法是把这个过程想象成像素的下降:大小比在2和3之间，所以我们必须在保留的像素之间删除一到两个像素。用这种方式缩小图像是可能的，但结果的质量很低——图10.34中的图像是使用像素下降制作的。然而，像素下降非常快，在交互操作过程中预览调整后的图像是一个合理的选择。
&nbsp;&nbsp;&nbsp;&nbsp;考虑调整图像大小的方法是将其视为重采样操作:我们希望在由new定义的特定网格上的图像的一组样本
&nbsp;&nbsp;&nbsp;&nbsp;我们通过从输入样本重建的连续函数采样来得到它们(图10.36)。从这个角度来看，它只是一系列标准的图像处理操作:首先，我们从输入样本中重建一个连续函数，然后，我们对该函数进行采样，就像我们对其他连续图像进行采样一样。为了避免混淆工件，需要在每个阶段使用适当的过滤器。
&nbsp;&nbsp;&nbsp;&nbsp;一个小的例子如图10.37所示:如果原图像是12 x 9像素，新图像是8 x 6像素，那么每个维度的输出像素是输入像素的2/3，因此它们在图像上的间距是原样本间距的3/2。
&nbsp;&nbsp;&nbsp;&nbsp;为了得到每个输出样本的值，我们需要以某种方式计算样本之间图像的值。像素下降算法为我们提供了一种方法:取输入图像中最接近的样本值，并将其作为输出值。这完全等价于用1像素宽(半径为1 / 2)的盒形滤波器重建图像，然后进行点采样。
&nbsp;&nbsp;&nbsp;&nbsp;当然，如果选择像素下降或其他非常简单的过滤的主要原因是性能，则永远不会将该方法作为特殊实现一般重建和重采样程序的案例。事实上，由于不连续，很难使盒滤波器工作在一个通用的框架。但是，对于高质量的重采样，重构/采样框架提供了宝贵的灵活性。
&nbsp;&nbsp;&nbsp;&nbsp;要计算出算法细节，最简单的方法是下拉到ID并讨论对序列进行重采样。编写实现的最简单方法是使用我们在10.2.5节中定义的重构函数。
~~~
function resample(sequence a，float x0,float dx int n,filter f)
    create sequence b of lenght n
    for i = 0 to n-1 do
        b[i] = reconstruct(a,f,x0+idx)
    reutrn b
~~~
&nbsp;&nbsp;&nbsp;&nbsp;参数zo根据旧序列的样本给出新序列的第一个样本的位置。也就是说，如果第一个输出样本落在输入序列中的样本3和4之间，则To为3.5。
&nbsp;&nbsp;&nbsp;&nbsp;该程序通过将输入序列与连续滤波器进行卷积，然后对其进行点采样来重建连续图像。这并不是说这两个操作是依次发生的——连续函数只在原则上存在，它的值只在采样点处计算。但在数学上，这个函数计算的是函数a * f的一组点样本。
&nbsp;&nbsp;&nbsp;&nbsp;这个点采样似乎是错误的，因为我们刚刚说过，一个信号应该用一个适当的平滑滤波器进行采样，以避免混叠。我们应该将重构函数与采样滤波器g和点采样g* (f* a)进行卷积。但由于这与(g* f) *相同,我们可以将采样滤波器与重构滤波器一起滚动;我们只需要一个卷积操作(图10.38)。这种组合的重构和采样滤波器称为重采样滤波器。
&nbsp;&nbsp;&nbsp;&nbsp;在重新采样图像时，我们通常在旧图像的单位中指定一个源矩形，该矩形指定我们希望在新图像中保留的部分。例如，使用第三章中的像素采样定位约定，我们用来重新采样整个图像的矩形是(-0.5,nold -0.5) x (-0.5, nold -0.5)。
给定源矩形(Ti, Th) x (yi, yh)，新图像的样本间距为Ar = (Th -)/new，在r中为Ay = (yh - yi)/nnew，在y中为(yh - yi)/nnew。左下样本位于(T + Ar/2,yι + Ay/2)。
&nbsp;&nbsp;&nbsp;&nbsp;修改一维伪代码以使用这种约定，并将对重构函数的调用扩展为隐含的双循环，我们得到
~~~
function resample(sequence a，float x0,float dx int n,filter f)
    create sequence b of lenght n
    for i=0 to n-1 do
        s = 0
        x = x0+i*dx
            for j = {x -r} to {x+r} do
                s = a[j]f(x-j)
            b[i]=s
    reutrn b
~~~
&nbsp;&nbsp;&nbsp;&nbsp;这个例程包含了重新采样图像的所有基础知识。最后一个需要解决的问题是如何处理图像的边缘，我们可以做以下几件事：
+ 只要在序列的末尾停止循环即可。这相当于在图像的所有边都填充0。
+ 将所有数组访问剪辑到序列的末尾——也就是说，当我们想要访问[-1]时，返回一个[0]。这相当于通过扩展最后一行或最后一列来填充图像的边缘。
+ 在接近边缘时修改过滤器，使其不会超出序列的边界。
&nbsp;&nbsp;&nbsp;&nbsp;第一种方法导致我们在重新采样整个图像时，边缘变暗，这并不令人满意。第二种方法很容易实现;第三种可能是表现最好的。修改靠近图像边缘的过滤器最简单的方法是将其重新规格化:用过滤器除以位于图像内的过滤器部分的和。这样，滤波器的总和总是1除以实际的图像样本，所以它保留了图像的强度。出于性能考虑，最好是在边缘(需要重正化)的过滤器半径内处理与中心(包含更多像素，不需要重正化)分开的像素带。
&nbsp;&nbsp;&nbsp;&nbsp;重采样滤波器的选择很重要。有两个独立的问题:过滤器的形状和大小(半径)。由于滤波器既是重构滤波器又是采样滤波器，这两种作用的要求影响了滤波器的选择。对于重建，我们希望一个滤波器足够平滑，以避免我们放大图像时的混叠工件，并且滤波器应该是无波纹的。对于采样，过滤器应该足够大，以避免采样不足，并且足够平滑，以避免moiré工件。图10.39说明了这两种不同的需求。
&nbsp;&nbsp;&nbsp;&nbsp;通常，我们会选择一个滤波器形状，并根据输入和输出的相对分辨率缩放它。两个分辨率中较低的一个决定了滤波器的大小:当输出的采样比输入的更粗(下采样，或缩小图像)，适当采样所需的平滑大于重构所需的平滑，因此我们根据输出样本间距(图10.39中的半径3)来调整滤波器的大小。另一方面，当输出采样更精细(上采样，或放大图像)时，重构所需的平滑占主导(重构函数已经足够平滑，可以以比开始时更高的速率采样)，因此滤波器的大小由输入样本间距(图10.39中的半径1)决定。
&nbsp;&nbsp;&nbsp;&nbsp;选择过滤器本身就是在速度和质量之间进行权衡。常见的选择是盒子过滤器(当速度是最重要的)，帐篷过滤器(中等质量)，或分段立方(优秀的质量)。在分段三次情况下，可以通过fB和fc之间的插值来调整平滑程度;米切尔-尼特拉瓦利滤镜是一个不错的选择。
&nbsp;&nbsp;&nbsp;&nbsp;就像图像滤波一样，可分离滤波器可以提供显著的加速。基本思想是首先重新采样所有行，生成宽度改变但高度不变的图像，然后重新采样该图像的列以生成最终结果(图10.40)。修改前面给出的伪代码以利用这种优化是相当简单的。

***
### 10.5抽样理论
&nbsp;&nbsp;&nbsp;&nbsp;如果你只对实现感兴趣，你可以停止阅读这里;前几节中的算法和建议将让您实现执行采样和重构的程序，并获得出色的结果。
&nbsp;&nbsp;&nbsp;&nbsp;然而，有一个更深入的抽样数学理论，其历史可以追溯到第一次在电信中使用抽样表示。抽样理论回答了许多严格基于规模论证的推理难以回答的问题。
但最重要的是，抽样理论为抽样和重建工作提供了有价值的见解。它为学习它的学生提供了一套额外的智力工具，用于推理如何用最有效的代码实现最佳结果。
#### 10.5.1傅里叶变换
&nbsp;&nbsp;&nbsp;&nbsp;傅里叶变换和卷积是构成抽样理论基础的主要数学概念。你可以在许多关于分析的数学书中读到傅里叶变换，也可以在关于信号处理的书中读到。
&nbsp;&nbsp;&nbsp;&nbsp;傅里叶变换的基本思想是通过将所有频率的正弦波相加来表示任何函数。通过为不同的频率使用适当的权重，我们可以安排正弦信号相加为我们想要的任何(合理的)函数。
$$
\sum_{n = 1,3,5\dots}^{\infty}\frac{4}{\pi n}sing2\pi nx
$$
&nbsp;&nbsp;&nbsp;&nbsp;这个傅立叶级数从频率为1.0的正弦波(sin2nr)开始，其频率与方波相同，其余项添加越来越小的修正以减少波纹，并在极限下精确再现方波。注意，和中的所有项的频率都是方波频率的整数倍。这是因为其他频率产生的结果与方波的周期不同。
&nbsp;&nbsp;&nbsp;&nbsp;一个令人惊讶的事实是，一个信号并不一定是周期性的，以这种方式表示为正弦信号的和:一个非周期信号只需要更多的正弦信号。我们不是对离散的正弦信号序列求和，而是对连续的正弦信号族积分。例如，一个盒子
        kjdslkjdklj
函数可以写成余弦波族的积分:
$$
\int_{-\infty}^{\infty}\frac{sin\pi u}{\pi n}cos2\pi uxdu
$$
&nbsp;&nbsp;&nbsp;&nbsp;(10.6)式中的这个积分是无穷多个余弦相加，将频率u的余弦乘以sin /的权重。当我们包含越来越高的频率时，结果收敛于框函数(参见图10.42)。当函数f以这种方式表示时，这个权重，即频率u的函数，称为f的傅里叶变换，记为f。函数f告诉我们如何通过对一系列正弦信号的积分来构造f:
$$
\int_{-\infty}^{\infty}\hat f(u)e^{2\pi iux}du
$$
&nbsp;&nbsp;&nbsp;&nbsp;式(10.7)被称为傅里叶反变换(IFT)，因为它以f的傅里叶变换开始，以f结束。
&nbsp;&nbsp;&nbsp;&nbsp;注意，在式(10.7)中，复指数e2niuz已经取代了前式中的余弦。f是一个复值函数。为了控制正弦信号的相位和频率，需要复数的机制;这对于表示任何不对称的函数都是必要的。f的大小被称为傅里叶频谱，对于我们的目的来说，这就足够了——我们不需要担心相位或直接使用任何复数。
&nbsp;&nbsp;&nbsp;&nbsp;注意术语“傅里叶变换”既用于函数f，也用于从f计算f的运算。不幸的是，这种相当模糊的用法是标准的。
从f计算f和计算f非常相似
$$
\hat f(u)=\int_{-\infty}^{\infty}\hat f(u)e^{2\pi iux}du \tag)
$$
&nbsp;&nbsp;&nbsp;&nbsp;式(10.8)称为(正向)傅里叶变换(FT)。指数中的符号是傅里叶反变换和正变换的唯一区别，这只是一个技术细节。出于我们的目的，我们可以将FT和IFT看作相同的操作。
&nbsp;&nbsp;&nbsp;&nbsp;有时，f-f的表示并不方便，然后，我们表示f的傅里叶变换除以f (f)和f的傅里叶反变换除以f- 1[f]
&nbsp;&nbsp;&nbsp;&nbsp;一个函数和它的傅里叶变换有许多有用的联系。我们将在本章后面使用的一些事实(其中大多数很容易验证)是
&nbsp;&nbsp;&nbsp;&nbsp;一个函数及其傅里叶变换有相同的平方积分:
$$
\int(f(x))^2 = \int(hat f(u))^2du
$$
&nbsp;&nbsp;&nbsp;&nbsp;物理上的解释是两者具有相同的能量(图10.43)。
&nbsp;&nbsp;&nbsp;&nbsp;特别地，将一个函数的傅里叶变换乘以a
&nbsp;&nbsp;&nbsp;&nbsp;沿r轴拉伸一个函数，将其沿u轴的傅里叶变换压缩相同的因子(图10.44):
F(F) = bf(bz)
(b的重整是保持能量不变的必要条件)
&nbsp;&nbsp;&nbsp;&nbsp;这意味着，如果我们对一组宽度和高度不同的函数感兴趣(比如所有以0为中心的方框函数)，那么我们只需要知道一个规范函数的傅里叶变换(比如宽度和高度都为1的方框函数)，我们就可以很容易地知道该函数的所有缩放和放大版本的傅里叶变换。
&nbsp;&nbsp;&nbsp;&nbsp;例如，我们可以立即推广式(10.6)得到宽b高a的盒子的傅里叶变换:
$$
ab\frac{sin\pi bu}{\pi bu}
$$
&nbsp;&nbsp;&nbsp;&nbsp;f的平均值等于f(0)这是有意义的，因为f(0)应该是信号的零频率分量(如果我们考虑的是电压，则是直流分量)。
&nbsp;&nbsp;&nbsp;&nbsp;如果f是实数(对我们来说总是如此)f是偶函数即f(u) f(-u)同样地，如果f是偶函数，那么f就是实数(这个不是通常在定义域是这样的，但记住，我们只关心f)的大小。
#### 10.5.2卷积与傅里叶变换
&nbsp;&nbsp;&nbsp;&nbsp;傅里叶变换最后一个值得特别提及的性质是它与卷积的关系(图10.45)。简单地说,
$$
F(f*g) = \hat f \hat g
$$
两个函数卷积的傅里叶变换等于傅里叶变换的乘积。按照现在熟悉的对称性，
$$
\hat f* \hat g = \tau \lbrace fg \rbrace
$$
&nbsp;&nbsp;&nbsp;&nbsp;两个傅里叶变换的卷积等于两个函数乘积的傅里叶变换。从定义中推导这些事实是相当直接的。
&nbsp;&nbsp;&nbsp;&nbsp;这种关系是傅里叶变换在研究采样和重建效果时有用的主要原因。我们已经知道了如何从卷积的角度来看待采样，滤波和重构;现在傅里叶变换给了我们一个新的域-频率域，在这个域里这些运算只是乘积。
#### 10.5.3傅里叶变换库
&nbsp;&nbsp;&nbsp;&nbsp;现在我们有了一些关于傅里叶变换的事实，让我们看一些单独函数的例子。特别地，我们将研究10.3.1节中的一些滤波器，它们的傅里叶变换如图10.46所示。我们已经看到了盒子函数:
π或
Ffbox] =
T = sincπu。
πน
sinr/z函数非常重要，它有自己的名字，sinc z。
帐篷函数是盒子与自身的卷积，所以它的傅里叶变换就是盒子函数的傅里叶变换的平方
F(值)= π2
&nbsp;&nbsp;&nbsp;&nbsp;我们可以继续这个过程，得到b样条滤波器的傅里叶变换(见练习3):
和
说
F[fB] = π4u4
.py。
&nbsp;&nbsp;&nbsp;&nbsp;高斯函数有一个很好的傅里叶变换
F (fG) = e - 2/2(2πu)
&nbsp;&nbsp;&nbsp;&nbsp;这是另一个高斯函数!标准差为1.0的高斯变成了标准差为1/2π的高斯。
#### 10.5.4采样理论中的狄拉克脉冲
&nbsp;&nbsp;&nbsp;&nbsp;脉冲在采样理论中很有用的原因是我们可以用它来讨论连续函数和傅里叶变换中的样本。我们表示一个样本，它有一个位置和一个值，通过脉冲转换到那个位置并按那个值缩放。位置A处的值为b的样本用bo(x - A)表示，这样我们就可以将函数f(z)在A处的采样操作表示为f乘以δ(r - A)，结果为f(A)δ(r - A)。
&nbsp;&nbsp;&nbsp;&nbsp;因此，在一系列等间隔点处对函数进行采样表示为将函数乘以一系列等间隔脉冲的和，称为脉冲序列(图10.47)。周期为T的脉冲序列，也就是脉冲间隔为T的距离，是

&nbsp;&nbsp;&nbsp;&nbsp;sy的傅里叶变换和si是一样的:所有整数频率的脉冲序列。当我们把脉冲序列乘以正弦函数并积分时你就能明白为什么这是对的。最后我们把所有整数处的正弦值加起来。对于非整数频率，这个和将完全抵消为零，对于整数频率，它将发散为+ oo。
&nbsp;&nbsp;&nbsp;&nbsp;由于傅里叶变换的膨胀特性，我们可以猜测周期为T的脉冲序列的傅里叶变换(就像s1的膨胀)是一个周期为1/T的脉冲序列。空间域的采样越细，脉冲在频域的距离就越远。
#### 10.5.5采样和混叠
&nbsp;&nbsp;&nbsp;&nbsp;既然我们已经建立了数学机制，我们需要从频域的角度来理解采样和重构过程。引入傅里叶变换的关键优点是，它使卷积滤波对信号的影响更加清晰，并更精确地解释了为什么在采样和重构时需要滤波。
&nbsp;&nbsp;&nbsp;&nbsp;我们从原始的连续信号开始这个过程。一般来说，它的傅里叶变换可以包含任何频率的分量，尽管对于大多数类型的信号(特别是图像)，我们预计内容会随着频率的升高而减少。图像在零频率处也倾向于有一个大的分量，记住零频率分量，或DC，是整个图像的积分，因为图像都是正的值，这往往是一个大的数字。
&nbsp;&nbsp;&nbsp;&nbsp;让我们看看如果我们不做任何特殊的滤波采样和重建傅里叶变换会发生什么(图10.48)。当我们对信号进行采样时，我们将操作建模为与一个脉冲序列的乘法;采样信号为fsT。由于乘法卷积的性质，采样信号的FT i
回想一下&是卷积的恒等式。这意味着
(f* 1/T)(u) = f(u -i/T);
i = 00)。
&nbsp;&nbsp;&nbsp;&nbsp;也就是说，与脉冲序列卷积得到一系列等间距的f频谱副本。对于这个看似奇怪的结果，一个很好的直观解释是，所有这些副本只是表达了这样一个事实(正如我们在10.1.1节看到的)，即一旦我们采样了，与采样频率相差整数倍的频率就无法区分了——它们将产生完全一样的样本。原始谱称为基谱，复制的谱称为混叠谱。
&nbsp;&nbsp;&nbsp;&nbsp;如果信号的这些拷贝的频谱重叠，问题就开始了，如果信号包含任何超过样本频率一半的重要内容，就会发生重叠。当这种情况发生时，光谱就会增加，不同频率的信息就会不可逆地混合在一起。这是混叠可能发生的第一个地方，如果它发生在这里，这是由于采样不足——为信号使用过低的采样频率。
&nbsp;&nbsp;&nbsp;&nbsp;假设我们用最近邻技术重构信号。这等价于与宽度为1的盒子进行卷积。(用于实现此目的的离散-连续卷积与代表样本的一系列脉冲的连续卷积相同。)卷积乘法性质意味着重构信号的频谱将是采样信号的频谱与盒子的频谱的乘积。由此得到的重构傅里叶变换包含了基谱(尽管在较高频率时有些衰减)，加上所有混叠谱的衰减副本。因为盒子有一个相当宽的傅里叶变换，这些衰减的混叠光谱是重要的，它们是第二种形式的混叠，由于一个不充分的重建滤波器。这些别名组件在图像中表现为正方形的模式，这是最近邻重构的特征。
##### 防止采样中的混叠
&nbsp;&nbsp;&nbsp;&nbsp;为了进行高质量的采样和重构，我们需要适当地选择采样和重构滤波器。从频域的角度来看，采样时低通滤波的目的是限制信号的频率范围，使混叠谱不与基谱重叠。图10.49显示了采样率对采样信号的傅里叶变换的影响。较高的采样率使混叠光谱离得更远，最终，剩下的任何重叠都无关紧要。
&nbsp;&nbsp;&nbsp;&nbsp;关键的准则是频谱的宽度必须小于副本之间的距离——也就是说，信号中出现的最高频率必须小于样本频率的一半。这被称为奈奎斯特准则，而允许的最高频率被称为奈奎斯特频率或奈奎斯特极限。奈奎斯特-香农采样定理指出，一个频率不超过奈奎斯特极限的信号(或者换句话说，一个带宽受奈奎斯特频率限制的信号)，原则上可以精确地从样本中重构出来。
&nbsp;&nbsp;&nbsp;&nbsp;对于一个特定的信号，如果有足够高的采样率，我们就不需要使用采样滤波器。但是，如果我们面对的是一个频率范围很广的信号(比如一个有锋利边缘的图像)，我们必须使用采样滤波器来限制信号的带宽，然后才能对其进行采样。图10.50显示了三个低通(平滑)滤波器在频域的效果，图10.51显示了在采样时使用相同滤波器的效果。即使频谱重叠而没有滤波，用低通滤波器卷积信号可以缩小频谱，足以消除重叠，并产生滤波信号的良好采样表示。当然，我们已经失去了高频信号，但这总比让它们与信号混淆变成人工制品要好。
##### 在重构中防止混叠
从频域的角度来看，重构滤波器的工作是在保留基谱的同时去除混叠谱。在图10.48中，我们可以看到最粗糙的重构滤波器，即盒子，确实衰减了混叠光谱。最重要的是，它完全阻断了所有混叠光谱的直流峰。
&nbsp;&nbsp;&nbsp;&nbsp;这是所有合理的重构滤波器的一个特点:它们在采样频率的所有倍数处的频率空间都为零。这和空间域中的无波纹性质是等价的。
&nbsp;&nbsp;&nbsp;&nbsp;因此，一个好的重构滤波器需要是一个好的低通滤波器，并附加了完全阻断采样频率的所有倍数的要求。
&nbsp;&nbsp;&nbsp;&nbsp;使用不同于盒形滤波器的重构滤波器的目的是为了更彻底地消除混叠谱，减少高频伪影泄漏到重构信号中，同时尽可能少地干扰基谱。图10.52说明了在重建过程中使用不同过滤器的效果。正如我们所看到的，盒子过滤器是相当“漏”的，即使样本率足够高，也会导致大量的工件。帐篷滤波器，导致线性插值，衰减高频更多，导致更温和的伪影，和b样条滤波器非常平滑，控制混叠光谱非常有效。它还使基谱平滑了一些——这是我们之前看到的平滑和混叠之间的权衡。
##### 防止重采样中的混叠
当重构和采样操作在重采样中结合时，同样的原理也适用，但由一个滤波器同时完成重构和采样的工作。图10.53说明了重采样滤波器必须去除混叠光谱，使光谱足够窄，以便在新的采样率下进行采样。
#### 10.5.6 理想过滤器vs.有用过滤器
根据频域分析的逻辑结论，在频域中正好是一个盒子的滤波器是采样和重构的理想选择。这样的滤波器可以防止在这两个阶段的混叠，而不会降低奈奎斯特频率以下的频率。
&nbsp;&nbsp;&nbsp;&nbsp;回想一下，反傅里叶变换和正傅里叶变换本质上是相同的，所以空间域滤波器的傅里叶变换是函数sin πr/πr = sinc πr。
&nbsp;&nbsp;&nbsp;&nbsp;然而，sinc滤波器在实践中通常不用于采样或重构，因为它是不切实际的，因为即使根据频域标准它是最优的，它也不能产生最好的结果，许多应用。
&nbsp;&nbsp;&nbsp;&nbsp;对于采样来说，sinc滤波器的无限范围，以及随着距离中心的距离，其衰减速率相对较慢，是一个不利因素。此外，对于某些类型的采样，负叶是有问题的。高斯滤波器即使是在必须从输入信号中去除高频模式的困难情况下，也是一种优秀的采样滤波器，因为它的傅里叶变换呈指数下降，没有容易让混淆的凸起。对于不那么困难的情况，帐篷过滤器通常就足够了。
&nbsp;&nbsp;&nbsp;&nbsp;对于重构，正弦函数的大小再次产生了问题，但更重要的是，许多波纹在重构信号中产生了“振铃”伪影。

***
### 练习
1. 证明了离散卷积是交换的和结合的。对连续卷积做同样的处理。
2. 离散连续卷积不能交换，因为它的参数有两种不同的类型。证明它是结合的。
3. 证明b样条是四个盒函数的卷积。
4. 通过使用以下(不正确的)定义(参见214页的脚注)来证明卷积的“翻转”定义是必要的:
$$
(a*b)[i]=\sum_ja{j}b{i+j}
$$
5. 证明$\tau\lbrace F *g \rbrace = \hat f*\hat g$ 和$ \hat f * \hat g = \tau \lbrace fg \rbrace $。
6. 式10.4可以解释为a与滤波器J的卷积。为“去波纹”滤波器f写一个数学表达式。画出将盒子、帐篷和b样条滤波器缩放到s = 1.25去波纹后的滤波器。
