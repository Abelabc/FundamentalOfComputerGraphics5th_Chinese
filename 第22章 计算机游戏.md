*边学边翻译，督促自己不能落下，同时也留点记忆*

# <center>**第二十二章 计算机游戏**</center> 

&nbsp;&nbsp;&nbsp;&nbsp;在计算机图形的所有应用中，计算机和电子游戏可能最吸引人的注意。为特定游戏选择的图像方法不仅会影响到游戏引擎代码，还会影响到美术资产创造，有时甚至会影响到游戏玩法或核心游戏机制。
&nbsp;&nbsp;&nbsp;&nbsp;虽然游戏图像依赖于前面所有章节的内容，但有两个章节是特别相关的。游戏需要高效地使用图像硬件，所以理解第17章的内容非常重要。
&nbsp;&nbsp;&nbsp;&nbsp;在这一章中，我将详细阐述应用于游戏开发中的图像的具体考虑因素，从游戏运行的平台到游戏制作过程。
***
### 22.1平台
&nbsp;&nbsp;&nbsp;&nbsp;在此，我使用“平台”一词指的是游戏所针对的硬件、操作系统和API(应用程序编程接口)的特定组合。游戏运行在各种各样的平台上，从用于基于浏览器的游戏的虚拟机到使用专门硬件和api的dedicäted游戏机。
&nbsp;&nbsp;&nbsp;&nbsp;在过去，针对单一平台设计游戏是很常见的。不断增长的游戏开发成本使得这种情况非常罕见;多平台游戏开发是现在的常态。支持多个平台所增加的开发成本可以通过潜在的两倍或三倍的客户群来偿还。
&nbsp;&nbsp;&nbsp;&nbsp;有些平台的定义相当松散。例如，当面向Windows PC平台开发一款游戏时，开发者必须考虑到各种可能的硬件配置。游戏甚至可以在开发时并不存在的PC配置上运行(并且运行良好)!这只有通过定义Windows平台的api提供的抽象才能实现。
&nbsp;&nbsp;&nbsp;&nbsp;开发人员考虑图形性能差异的一种方法是根据系统功能调整图形质量。这可以确保在低端系统上获得合理的性能，同时在高性能系统上仍然获得有竞争力的视觉效果。这种调整有时是通过分析系统性能自动完成的，但更多情况下，这种控制是由用户来完成的，用户可以最好地判断自己对质量和速度的个人偏好。显示分辨率是最容易调整的，其次是抗锯齿质量。为视觉效果(如阴影和动态模糊)提供几个质量级别也是相当常见的，包括完全关闭效果的选项。
&nbsp;&nbsp;&nbsp;&nbsp;图像性能的差异可能非常大，以至于有些机器可能无法以可玩的帧率运行游戏，即使是在最低质量设置下;因此，PC游戏开发者会发布每款游戏的最低和推荐机器规格。
&nbsp;&nbsp;&nbsp;&nbsp;作为平台，游戏主机的定义非常严格。在为任天堂的Wii主机开发游戏时，开发者清楚游戏将运行在什么硬件上。如果平台的硬件实现发生了改变(通常是为了降低制造成本)，控制台制造商必须确保新实现的行为与前一个完全相同，包括时间和性能。这并不是说主机开发者的任务很容易;控制台api往往不那么抽象，更接近底层硬件。这给主机开发带来了一系列困难。从某种意义上说，多平台开发(通常包括至少两个不同的主机平台，通常也包括Windows)是最困难的，因为多平台游戏开发者既没有固定平台的保证，也没有单一高级APL的便利。
&nbsp;&nbsp;&nbsp;&nbsp;Adobe Flash等基于浏览器的虚拟机是一种有趣的游戏平台。虽然这样的虚拟机运行在一个广泛的硬类从个人电脑到手机，虚拟机所提供的高度抽象性造就了一个稳定统一的开发平台。这些平台相对容易的开发和巨大的潜在用户群使得它们对游戏开发者越来越有吸引力。然而，这些平台是由支持的硬件的最低公分母定义的，虚拟机的性能低于任何给定平台上的本机代码。基于这些原因，这类平台最适合图像要求不高的游戏。
平台还可以以开放开发为特征，这是一个商业或法律区别，而不是技术区别。举个例子来说吧，Windows是开放的，即开发工具随处可见，并且没有任何把关者能够控制Windows游戏市场的准入。苹果的iPhone是一个限制更严格的平台，因为所有的应用程序都需要通过认证过程，某些类别的应用程序是完全禁止的。主机是最具限制性的游戏平台，开发工具的访问受到严格控制。随着在线主机游戏市场的出现，这一趋势变得更加开放。一个特别有趣的例子是微软的Xbox LIVE社区游戏服务，它的开发工具是免费的，“把关”主要是通过同行评审来完成的。通过该服务分发的游戏必须使用微软提供的虚拟机平台以保证安全的原因。
&nbsp;&nbsp;&nbsp;&nbsp;游戏平台决定了游戏体验的许多元素。例如，PC玩家使用键盘和鼠标，而主机玩家则使用专门的游戏控制器。许多主机游戏支持同一台主机上的多个玩家，要么共享屏幕，要么为每个玩家提供一个窗口。由于键盘和鼠标共享的困难，这种玩法在PC上是找不到的。手持游戏系统的控制方案与触屏手机不同。
尽管游戏平台各不相同，但还是可以看出一些共同的趋势。
&nbsp;&nbsp;&nbsp;&nbsp;大多数平台都有多个处理核，分为通用(CPU)和特定图形(GPU)。随着时间的推移，性能的提高主要是由于核心couni的增加;个人核心绩效的提升是模型。随着GPU内核的普遍增长，GPU和CPU内核之间的界限越来越模糊。存储容量的增长速度往往比处理能力的增长速度慢，通信带宽(内核之间以及每个内核和存储之间)的增长速度也更慢。
***
### 22.2资源有限
&nbsp;&nbsp;&nbsp;&nbsp;游戏图像的主要挑战之一是需要管理多个有限资源池。每个平台对硬件资源有自己的限制，比如处理时间、存储和内存带宽。在更高的层面上，发展资源也需要管理;这里有一个由程序员、美工和游戏设计师组成的固定规模的团队，他们在有限的时间内完成游戏，希望不用加班太多!在决定采用哪种图形技术时，需要考虑到这一点。
#### 22.2.1处理时间
&nbsp;&nbsp;&nbsp;&nbsp;早期的游戏开发者只需要担心单个处理器的预算问题。目前的游戏平台包含多个CPU和GPU核。这些处理器需要小心地同步，以避免死锁或过度停顿。
&nbsp;&nbsp;&nbsp;&nbsp;由于单个呈现命令所消耗的时间是高度可变的，因此图形处理器通过命令缓冲区与系统的其余部分解耦。这个缓冲区充当一个队列;命令在一端存放，GPU从另一端读取渲染命令。增加这个缓冲区的大小可以减少GPU短缺的机会。对于游戏来说，在将渲染命令发送到GPU之前缓冲一整帧的渲染命令是相当普遍的;这保证了GPU饥饿不会发生。然而，这种方法需要为两个完整帧的命令保留足够的存储空间(GPU在一个帧上工作，而CPU在另一个帧上存放命令)。它还增加了用户输入和显示之间的延迟，这对于快节奏的游戏来说是个问题。
&nbsp;&nbsp;&nbsp;&nbsp;处理预算由帧率决定，帧率是用场景的新渲染刷新帧缓冲区的频率。在固定平台(如主机)上，用户所体验到的帧速率基本上与游戏开发者所看到的相同，因此可以施加相当严格的帧速率限制。大多数游戏的目标是每秒30帧(fps);在响应延迟特别重要的游戏中，目标通常是60fps。在高度可变的平台(如pc)上，帧速率预算的定义(必然)更加宽松。
&nbsp;&nbsp;&nbsp;&nbsp;所需的帧率为图形程序员提供了每帧工作的固定预算。在30 fps目标的情况下，CPU核心有33毫秒的时间来收集输入，处理游戏逻辑，执行任何物理模拟，遍历场景描述，并向图像发送渲染命令
硬件。与此同时，必须处理其他任务，如音频和网络处理，它们有自己所需的响应时间。当这种情况发生时，GPU通常会执行上一帧提交的图形命令。
&nbsp;&nbsp;&nbsp;&nbsp;在大多数情况下，CPU内核是一种同构资源;所有的核心都是一样的，并且它们中的任何一个都同样适合特定的工作负载(有一些例外，例如索尼的PLAYSTATION 3主机中使用的Cell处理器)。
&nbsp;&nbsp;&nbsp;&nbsp;相比之下，gpu包含不同种类的资源组合，每个资源专门用于特定的任务集。其中一些资源包含固定功能的硬件(用于三角形栅格化、alpha混合和纹理采样)，还有一些是可编程核心。在较老的gpu上，可编程核进一步分为顶点处理核和像素处理核;较新的GPU设计有统一的着色器核心，可以执行任何可编程着色器类型。
&nbsp;&nbsp;&nbsp;&nbsp;这种不同种类的资源分别编列预算。通常，在任何情况下，只有一种资源类型会成为瓶颈，而其他资源类型会有多余的容量。一方面，这是好的，因为这种能力可以在没有鹿群性能的情况下提高视觉质量。另一方面，它使提高性能变得更加困难，因为减少任何非瓶颈资源的使用都不会产生任何效果。即使减少了瓶颈资源的使用也只能略微提高性能，这取决于“下一个瓶颈”的利用程度。
#### 22.2.2存储
&nbsp;&nbsp;&nbsp;&nbsp;与任何现代计算系统一样，游戏平台拥有多级存储层次结构，顶部的存储类型更小、更快，底部的存储类型更大、更慢。这种安排是出于工程上的需要，尽管它确实使开发人员的生活变得复杂。大多数平台包括光盘存储，这是非常慢的，主要用于交付。在Windows等平台上，只需执行一次漫长的安装过程，就可以将所有数据从光盘转移到硬盘驱动器上，这大大加快了速度。光盘不再使用(除了作为反盗版措施)。在主机平台上，这种情况不太常见，尽管在保证硬盘存在的情况下有时会发生，比如在索尼的PLAYSTATION 3主机上。
更常见的情况是，硬盘驱动器(如果存在)仅用作光盘的缓存。
&nbsp;&nbsp;&nbsp;&nbsp;内存层次的下一步是RAM，它在许多平台上被分为通用系统RAM和VRAM(视频RAM)，后者得益于与图形硬件的高速接口。游戏关卡可能太大了在这种情况下，游戏开发者需要根据需要将数据移进和移出RAM。在Windows等平台上，虚拟内存通常用于此操作。在控制台平台上，通常采用自定义数据流和缓存系统。
&nbsp;&nbsp;&nbsp;&nbsp;最后，CPU和GPU都拥有各种片上存储器和缓存。它们非常小且快速，通常由图形API管理。
&nbsp;&nbsp;&nbsp;&nbsp;图像资源占用大量内存，所以它们是游戏开发中存储预算的主要关注点。纹理通常是最大的内存消耗者，其次是几何(顶点数据)，最后是其他类型的图形数据(如动画)。并非所有的内存都可以用于图像，音频也会占用一定的空间，游戏逻辑可能会使用相当大的数据结构。就处理时间而言，Windows上的预算往往比较宽松，因为在Windows上，用户系统上存在的确切内存量是未知的，虚拟内存包含了大量错误。相比之下，主机平台上的内存预算相当严格——通常情况下，首席程序员在电子表格上跟踪内存，而需要更多内存的程序员则需要从其他人那里请求、借用或窃取内存。
&nbsp;&nbsp;&nbsp;&nbsp;内存层次结构的不同级别不仅在大小上不同，而且在访问速度上也不同。这有两个独立的维度:延迟和带宽。
&nbsp;&nbsp;&nbsp;&nbsp;延迟是存储访问请求和最终实现之间的时间。这从几个时钟周期(对于片上缓存)到数百万个时钟周期(对于驻留在光盘上的数据)不等。延迟通常是读访问的一个问题(尽管写延迟也可能是一个问题，如果需要很快从内存中读回结果)。在某些情况下，读请求被阻塞，这意味着提交读请求的处理器核心在请求完成之前不能做任何其他事情。在其他情况下，读是非阻塞的;处理核心可以提交读请求，执行其他类型的处理，然后在它到达后使用读的结果。GPU对纹理的访问是一个非阻塞读取的例子;GPU设计的一个重要方面是找到“隐藏”纹理读取延迟的方法，即在完成纹理读取时执行不相关的计算。
&nbsp;&nbsp;&nbsp;&nbsp;为了隐藏延迟，相对于纹理访问必须有足够的计算量。这是一个重要的考虑着色器作者;计算和纹理访问的最佳组合一直在变化(有利于更多的计算)，因为内存无法跟上处理能力的增长。
&nbsp;&nbsp;&nbsp;&nbsp;带宽是指与存储器之间传输的最大速率。它通常以每秒千兆字节为单位。
#### 22.2.3开发资源
&nbsp;&nbsp;&nbsp;&nbsp;除了硬件资源，如处理能力和存储空间，游戏图像程序员还必须与另一种有限的资源竞争——他的队友的时间!在选择图形技术时，必须考虑到实现每种技术所需的工程资源，以及计算输入数据所需的任何工具(在许多情况下，工具可能比实现技术本身花费更多的时间)。也许最重要的是，必须考虑到对艺术家生产力的影响。大多数图像技术都是使用游戏美工所创造的资产，而这也是大多数现代游戏团队中最大的组成部分。图像程序员必须培养美术人员的生产力和创造力，这将最终决定游戏的视觉质量。

***
### 22.3优化技术
&nbsp;&nbsp;&nbsp;&nbsp;如何明智地利用这些有限的资源是游戏图像程序员的主要挑战。为此，通常使用各种优化技术。
&nbsp;&nbsp;&nbsp;&nbsp;在许多游戏中，像素着色器处理是一个主要瓶颈。大多数gpu都包含分层深度剔除硬件，这可以避免在闭塞表面上执行像素着色器。为了充分利用这种硬件，不透明对象可以前后呈现。或者，最佳的深度筛选使用可以通过执行深度预处理来实现，即，在正常渲染场景之前，将所有不透明的对象渲染到深度缓冲区中(没有任何颜色输出或像素着色器)。这确实会产生一些开销(因为需要两次呈现每个对象)，但在许多情况下，性能收益是值得的。
&nbsp;&nbsp;&nbsp;&nbsp;渲染对象的最快方法是根本不渲染它;因此，任何早期识别物体被遮挡的方法都是有用的。这不仅节省了像素处理，还节省了顶点处理，甚至节省了向图形API提交对象所需的CPU时间。视图截锥剔除(见第8.4.1节)是普遍使用的，但在许多游戏中它是不够的。通常使用高级闭塞剔除算法，利用数据结构如PVS(潜在可见集)或BSP(二叉空间分区)树来快速缩小潜在可见对象池。
&nbsp;&nbsp;&nbsp;&nbsp;即使一个物体是可见的，它可能在这样的距离，它的大部分细节可以删除而没有明显的效果。LOD(细节级)算法根据距离(或其他因素，如如屏幕覆盖范围或重要性)。这可以节省大量的处理，特别是顶点处理。如图22.1所示。
&nbsp;&nbsp;&nbsp;&nbsp;在许多情况下，处理甚至可以在游戏开始前执行。这种预处理的结果可以存储并使用每一帧，从而加快游戏的速度。这最常用于照明，其中全局照明算法用于计算整个场景的照明，并将其存储在光图和其他数据结构中以供以后使用。

***
### 22.4游戏类型
&nbsp;&nbsp;&nbsp;&nbsp;由于游戏需求千差万别，所以图像技术的选择取决于所开发的游戏类型。
&nbsp;&nbsp;&nbsp;&nbsp;处理时间的分配很大程度上取决于帧率。目前，大多数主机游戏的目标是每秒30帧，因为这样可以获得更高的图像质量。然而，某些具有快速玩法的游戏类型需要非常低的延迟，这类游戏通常以每秒60帧的速度呈现。这包括音乐游戏如《吉他英雄》和第一人称射击游戏如《使命召唤》。
&nbsp;&nbsp;&nbsp;&nbsp;帧率决定了渲染场景的可用时间。场景本身的组成也因游戏而异。大多数游戏都划分了背景几何(风景，大部分是静态的)和前景几何(角色和动态物体)。渲染引擎以不同的方式处理它们。例如，背景几何将经常有光图包含预先计算的照明，这是不可用的前景abjeet。预先计算的照明通常应用于前景对象通过某种类型的体积表示，可以考虑到每个对象随着时间的变化的位置。
&nbsp;&nbsp;&nbsp;&nbsp;有些游戏拥有相对封闭的环境，在这种环境中，摄像机基本上是固定的。最典型的例子是《Streer Fighter》系列等格斗游戏，但在某种程度上，《Devil May Cry》和《战神》等游戏也是如此。这些游戏拥有不受玩家直接控制的摄像头，游戏玩法倾向于从一个封闭环境移动到另一个封闭环境，在每个封闭环境中花费大量的游戏时间。这允许游戏开发者在每个房间或封闭环境中投入大量资源(处理、存储和美术时间)，从而获得非常高的图像保真度。
&nbsp;&nbsp;&nbsp;&nbsp;还有一些游戏拥有非常大的世界，在那里玩家可以自由移动。这在《侠盗猎车手》系列等“沙盒游戏”和《魔兽世界》等在线角色扮演游戏中最为明显。这类游戏给图像开发者带来了巨大的挑战，因为当玩家在每一帧中都能看到世界的很大一部分时，资源分配就变得非常困难。更复杂的是，玩家可以自由地前往以前遥远的世界，近距离观察它。这类游戏通常会改变一天中的时间，这使得光的预计算很难，如果不是不可能的话。
&nbsp;&nbsp;&nbsp;&nbsp;大多数游戏，如第一人称射击游戏，都介于这两个极端之间。玩家可以在每一帧中看到大量的风景，但是在游戏世界中的移动却受到了一定的限制。许多游戏还为每个游戏关卡设置了固定的时间，以便于照明预计算。
&nbsp;&nbsp;&nbsp;&nbsp;在不同的游戏类型中，渲染的前景对象的数量也有很大的不同。即时策略游戏如《命令与征服》系列通常在屏幕上有数十个甚至数百个可见单位。其他类型的游戏的可见角色数量更有限，而格斗游戏则是相反的情况，只有两个可见角色，每个角色都呈现出极高的细节。必须区分在任何时候可见的字符数量(这影响处理时间的预算)和可能在短时间内可见的惟一字符的数量(这会影响存储预算)。
&nbsp;&nbsp;&nbsp;&nbsp;游戏类型也决定了用户对图像的期望。举个例子来说吧，第一人称射击游戏在历史上便拥有较高的图像保真度，而这种期待也推动着我们在开发这类型新游戏时的图像设计;见图22.2。另一方面，解谜游戏通常具有相对简单的图像，所以大多数游戏开发者不会投入大量编程或美术资源为这类游戏开发逼真的图像。
尽管大多数游戏的目标是逼真的外观，但也有一些游戏尝试了更程式化的渲染。一个有趣的例子是Okami，如图22.3所示。
&nbsp;&nbsp;&nbsp;&nbsp;开发资源的管理也因游戏类型而异。大多数游戏的开发周期都是1到2年，即在游戏发行后结束。最近，可下载内容(DLC)越来越普遍，玩家可以在游戏发行后购买这些内容，所以需要为此预留一些开发资源。持续世界的在线游戏有一个永不停息的开发过程，其中会不断产生新的内容，至少只要游戏在经济上是可行的(可能需要几十年)。
&nbsp;&nbsp;&nbsp;&nbsp;创造性地利用特定游戏的特定要求和限制是熟练的游戏图像程序员的标志。《小小大星球》便是一个典型的例子，它拥有一个“2.5维”的游戏世界，包含少量的二维层，以及一个非互动的背景。这款游戏的图像质量非常出色，这是由于它使用了针对这类环境的特殊渲染技术;见图22.4。

***
### 22.5游戏制作过程
&nbsp;&nbsp;&nbsp;&nbsp;游戏制作过程始于基本的游戏设计或概念。在某些情况下(游戏邦注:如续作)，基本玩法和视觉设计非常清晰，只会进行增量修改。在新游戏类型的情况下，需要大量的原型来确定玩法和设计。大多数情况下都是处于中间位置，其中包含一些新的玩法元素，视觉设计也比较开放。在这一步之后，可能会有一个绿灯阶段向游戏发行商展示一些早期的演示版本或概念，以获得游戏的批准(和资金!)
&nbsp;&nbsp;&nbsp;&nbsp;下一步通常是前期制作。当其他团队致力于完成最后一款游戏时，一个小型核心团队则致力于对游戏引擎和制作工具链做出必要的改变，并制定任何新玩法元素的粗略细节。这个核心团队在严格的期限内工作。在现有的游戏发行后，团队的其他成员从一个应得的假期中回来，整个工具链和引擎必须为他们准备好。如果核心团队错过了这个截止日期，几十名开发人员可能会被闲置，这是一个非常昂贵的提议!
&nbsp;&nbsp;&nbsp;&nbsp;完整制作是下一步，整个团队将创造美术资产，设计关卡，调整游戏玩法，并对游戏引擎进行进一步修改。在一个完美的世界里，在这个过程中所做的一切都将用于最终的游戏中，但在现实中，游戏开发具有迭代的本质，这将导致一些工作被丢弃和重做。我们的目标是通过仔细的计划和原型设计最小化这种情况。
&nbsp;&nbsp;&nbsp;&nbsp;当游戏功能完成时，最后一个阶段就开始了。alpha版本通常指的是开始大量内部测试的版本，beta版本指的是开始大量外部测试的版本，黄金版本指的是提交给主机制造商的最终版本。但不同的公司对这些术语的定义略有不同。无论如何，测试或质量保证(QA)都是这一阶段的重要组成部分，它涉及到游戏开发工作室、发行商、主机制造商的测试人员，也可能包括外部QA承包商。这些不同的测试会产生错误报告，这些报告会被提交给游戏开发者，并一直持续到下一次重做。
&nbsp;&nbsp;&nbsp;&nbsp;在游戏发行后，大多数开发者会去度假一段时间，但一个小团队可能会留下来开发补丁或可下载内容。与此同时，一个小型核心团队一直致力于下一款游戏的前期制作。
&nbsp;&nbsp;&nbsp;&nbsp;美术资产创造是游戏制作的一个方面，与图像开发尤其相关，所以我将在此详细阐述。
#### 22.5.1 创建资产
&nbsp;&nbsp;&nbsp;&nbsp;虽然美术资产创造的确切过程因游戏而异，但我在此给出的概要是具有代表性的。在过去，一个美工可以从头到尾创造一个完整的资产，但现在这一过程更加专业化了，需要不同技能的人在不同时间致力于每个资产。其中一些阶段具有明显的依赖性(例如，一个角色在被操纵之前不能被动画化，并且在建模之前不能被操纵)。大多数游戏开发者都有明确的审批流程，即在资产进入下一个阶段之前，美术总监或首席美术师会在每个阶段签署文件。理想情况下，资产在每个阶段只进行一次，但实际上可能需要重新提交更改。
#####最初的建模
&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，美术资产的创建过程是从物体几何建模开始的。这一步是在Maya、MAX或Softimage等通用建模包中执行的。建模的几何图形将直接传递给游戏引擎，所以在保持良好轮廓的同时最小化顶点计数是很重要的。角色网格也必须被构造以便适应动画。
&nbsp;&nbsp;&nbsp;&nbsp;在这一阶段，通常创建纹理的二维表面参数化。重要的是，这种参数化是高度连续的，因为不连续需要顶点复制，并可能导致过滤工件。一个网格及其相关纹理参数化的例子如图22.5所示。
##### 纹理
&nbsp;&nbsp;&nbsp;&nbsp;在过去，纹理是一个简单的绘制颜色纹理的过程，通常在Photoshop中。现在，专门的细节建模包，如ZBrush或Mudbox通常用于雕刻精细的表面细节。图22.6和22.7显示了该过程的一个示例。
&nbsp;&nbsp;&nbsp;&nbsp;如果要用实际的几何图形来表示这些额外的细节，就需要数百万个三角形。相反，细节通常被“烘焙”到一个法线贴图中，应用到原始的粗网格上，如图22.8和22.9所示。
&nbsp;&nbsp;&nbsp;&nbsp;除了法线贴图，还创建了多个包含表面属性的纹理，如漫反射颜色、镜面颜色和平滑度(镜面功率)。它们要么在细节建模应用程序中直接绘制在表面上，要么在二维应用程序中(如Photoshop)绘制。所有这些纹理映射都使用在初始建模阶段定义的表面参数化。当在二维绘画应用程序中绘制纹理时，艺术家必须频繁地在绘画应用程序和其他应用程序之间切换，这些应用程序可以显示应用该纹理的对象的三维渲染。这个迭代过程如图22.10、22.11、22.12和22.13所示。
##### 着色
&nbsp;&nbsp;&nbsp;&nbsp;着色器通常应用于用于初始建模的同一个应用程序中。在这个过程中，一个着色器(来自为游戏定义的着色器集)被应用到网格上。从细节建模阶段产生的各种纹理被应用为这个着色器的输入，使用初始建模期间定义的表面参数化。通过视觉实验(“调整”)设置各种其他着色器输入;见图22.14。
##### 光照
&nbsp;&nbsp;&nbsp;&nbsp;在背景场景的情况下，照明艺术家通常会在建模、纹理和阴影已经完成后开始他们的工作。在预处理步骤中放置光源并计算其效果。这个过程的结果存储在lightmap中，供渲染引擎稍后使用。
##### 动画
&nbsp;&nbsp;&nbsp;&nbsp;角色网格需要经历几个与动画相关的额外步骤。制作游戏角色动画的主要方法是蒙皮。这需要一个平台，由附加到角色上的转换节点的层次结构组成过程称为索具。每个转换节点的影响区域被绘制到网格顶点的子集上。最后，动画师创建移动、旋转和缩放这些变换节点的动画，“拖动”它们后面的网格。
&nbsp;&nbsp;&nbsp;&nbsp;一个典型的游戏角色会有许多动画，对应于不同的运动模式(走，跑，转弯)以及不同的动作(如攻击)。就主角而言，动画的数量可以达到数百个。不同动画之间的过渡也需要定义。
&nbsp;&nbsp;&nbsp;&nbsp;对于面部动画，有时会使用另一种叫做变形目标的技术。在该技术中，直接操纵网格顶点来变形网格。变形网格的不同副本被存储(例如，不同的面部表情)，并在运行时由游戏引擎组合。变形目标的创建如图22.15所示。

***
### 笔记
&nbsp;&nbsp;&nbsp;&nbsp;有大量关于实时渲染和游戏编程的信息，无论是在书中还是在网上。以下是我个人熟悉的一些资源。
&nbsp;&nbsp;&nbsp;&nbsp;《游戏开发者杂志》(Game Developer Magazine)是关于游戏开发的一个很好的信息来源，如来自年度游戏开发者大会(GDC)和微软Gamefest大会上的演讲幻灯片。GPU Gems和ShaderX丛书也包含了很好的信息——前者和后者的前两本都可以在网上找到。
&nbsp;&nbsp;&nbsp;&nbsp;Eric Lengyel的《Mathematics for 3D Game Programming & Computer Graphics》已经出了第二版，它是用于图像和游戏中的各种数学类型的很好的参考。游戏编程中与图像密切相关的一个特定领域是碰撞检测，Christer Ericson的《Real-Time collision detection》便是这方面的权威资源。
&nbsp;&nbsp;&nbsp;&nbsp;自1999年第一版以来，Eric Haines和Tomas Akenine-Möller的RealTime Rendering一直致力于以彻底的方式覆盖这个快速发展的领域。作为这本书的长期粉丝，我很高兴有机会成为这本书第三版的共同作者，第三版于2008年年中出版。
&nbsp;&nbsp;&nbsp;&nbsp;阅读并不能确保你定期体验各种游戏，从而更好地理解各种游戏类型的需求以及当前的艺术状态。

***
### 练习
1. 检查两款不同游戏的视觉效果。你能推断出这两款游戏在图像要求上有什么不同吗?分析对渲染时间、存储预算等的影响。

