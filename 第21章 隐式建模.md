*边学边翻译，督促自己不能落下，同时也留点记忆*

# <center>**第二十一章 隐式建模**</center> 
***
&nbsp;&nbsp;&nbsp;&nbsp;计算机图形学中的隐式建模(也称为隐式曲面)涵盖了许多定义模型的不同方法。这些包括骨架隐式建模、偏移曲面、水平集、变分曲面和代数曲面。在本章中，我们将简要介绍这些方法，并详细描述如何构建骨架隐式模型。曲线可以用这种形式的隐式方程来定义
$$
f(x y) = 0.
$$
如果我们考虑一条半径为r的闭合曲线，比如圆，那么隐式方程可以写成
$$
F (x, y) = x^2 + y^2 - 2 \tag{21.1}
$$
&nbsp;&nbsp;&nbsp;&nbsp;f(x, y)的值可以是正的(圆外)，负的(圆内)，或者对于圆上的点为零。在三维空间中，等效的是围绕一组占据给定体积或空间区域的点的封闭曲面。体积形成一个标量场，也就是说，我们可以为每个点计算一个值，就像我们看到的圆一样，负值被隐式曲线或曲面所限制。可以将曲面可视化为场中的轮廓线，将点与特定值(如0)连接起来(见式(21.1))。
计算这样的曲面意味着在空间中寻找满足隐式方程的点;这种方法不太可能导致绘制圆的有效算法(在三维空间中更不可能)。这可能是采用参数曲线建模的算法方法的原因表面研究先于隐式方法;然而，有一些很好的理由开发算法来可视化隐式曲面。在本章中，我们将探讨从建模过程而不是从扫描仪中派生数据的含义。
&nbsp;&nbsp;&nbsp;&nbsp;尽管寻找隐式曲面的计算开销很大，但与其他建模方法相比，隐式建模技术具有一些优点。使用隐式方法简化了许多几何运算，包括:
+ 混合物的定义;
+ 构造立体几何(CSG)的标准集运算(并、交、差等);
+ 与其他隐函数的函数复合(例如，r函数、Barthe共混、Ricci共混和翘曲);
+ 内部/外部测试(例如，用于碰撞检测)。
&nbsp;&nbsp;&nbsp;&nbsp;表面的可视化可以通过直接射线追踪，使用一种算法(Kalra & Barr, 1989;米切尔,1990;哈特和贝克，1996;deGroot & Wyvill, 2005)或首先转换为多边形(Wyvill, McPheeters，威维尔，1986)。
&nbsp;&nbsp;&nbsp;&nbsp;最早的方法之一是由Ricci在1973年提出的(Ricci, 1973)，他也在同一篇论文中介绍了CSG。吉姆·布林在电子密度场中寻找轮廓的算法，称为Blobby分子(J.布林，
1982年)，西村的Metaballs(西村等人，1985年)和Wyvills的Soft Objects (Wyvill等人，1986年)都是隐式建模方法的早期例子。Jim Blinn的Blobby Man(见图21.1)是第一个非代数隐式模型的渲染。
***
### 21.1隐式函数、骨架原语和求和混合
&nbsp;&nbsp;&nbsp;&nbsp;在建模的背景下，隐函数被定义为一个函数f作用于一个点pe3，得到一个标量值R。
&nbsp;&nbsp;&nbsp;&nbsp;隐式函数fi(r, y,z)可以分解为距离函数d;(a, y， =)和衰减滤波函数' gi(r)，其中r表示到骨架的距离，下标表示第i个骨架元素。我们将使用以下符号:
$$
f_i(x,y,z) = g_i~o~d_i(x,y,z)\tag{21.2}
$$
&nbsp;&nbsp;&nbsp;&nbsp;一个简单的例子是点原语，我们用恒星向太空辐射热量的例子来做类比。可以在任何点p处测量该场值(本例中的温度)，通过取p到恒星中心的距离，并将该值提供给一个衰减滤波函数，类似于图21.2中给出的一个函数，就可以得到该场值。在这些样本函数中，星点中心的场被赋值为1;该值随距离递减。模型的曲面可以由隐式函数f(r, y, z)作为空间上的点，其值等于某个期望的iso值(iso);在星形例子中，iso E(0,1)的值是一个球壳。
&nbsp;&nbsp;&nbsp;&nbsp;一般来说，筛选函数(gi)的选择使字段值在骨架上最大化，并在距离的某个选定的距离处降为零骨架。在结果曲面混合在一起的简单情况下，一个物体的全局场f(r, y, z)，即隐函数，可以定义为
$$
f(x,y,z)= \sum_{i=1}^{i=n}f_i(x,y,z) \tag{21.3}
$$
&nbsp;&nbsp;&nbsp;&nbsp;其中n个骨架元素构成结果字段值。如图21.3所示，任意点(r,y, 2)处的场计算如式(21.3)所示。
&nbsp;&nbsp;&nbsp;&nbsp;在本例中，两个点原语被放置在很近的位置。当这两个点靠近时，表面会膨胀，然后融合在一起。使用术语过滤器函数，因为该函数使原语一起模糊，有点类似于图像的过滤器函数。求和共混是可应用于隐式曲面的最紧凑、最有效的共混操作(见式(21.3))。
&nbsp;&nbsp;&nbsp;&nbsp;使用支持有限的过滤函数的一个优点是远离p的原语贡献为零，因此不需要考虑(Wyvill et al.， 1986)。
#### 21.1.1 C'连续性和梯度
&nbsp;&nbsp;&nbsp;&nbsp;最基本的连续性形式是CO连续性，它确保函数中没有“跳跃”。用函数的导数定义高阶连续性(见第15章)。
&nbsp;&nbsp;&nbsp;&nbsp;在三维标量场f的情况下，一阶导数是一个称为梯度的向量函数，写为Vf，定义为
$$
\nabla f(p)= \lbrace \frac{\partial f(p)}{\partial x},\frac{\partial f(p)}{\partial y},\frac{\partial f(p)}{\partial z} \rbrace
$$
&nbsp;&nbsp;&nbsp;&nbsp;如果Vf在所有点上都有定义，三个一维偏导数各为CO，则f为C'。非正式地说，Cl表面连续性是指表面法线在表面上平滑地变化。表面法线是垂直于表面的单位向量。例如，如果在一个立方体的边缘上不能定义唯一的曲面法线，那么这个曲面就不是C'。对于隐式曲面上的点，可以通过归一化梯度向量Vf来计算曲面法线。在圆的例子中，里面的点是负值，外面的点是正值。对于许多类型的隐式曲面，内外的感觉是倒置的，由于法向量必须总是指向外，它可以是与梯度方向相反的。
&nbsp;&nbsp;&nbsp;&nbsp;骨架隐式原语是通过对无符号距离场应用衰减滤波函数创建的，如式(21.2)所示。尽管在骨架处的距离场从来不是Cl，但这些不连续可以通过使用合适的衰减函数来去除(Akleman & Chen, 1999)。如果一个算子g组合了隐函数fi和f2，其中所有点都是C'，那么g(f1, f2)不一定是C'。例如，可以使用最小和最大操作符来实现一个清晰的CSG连接。这种组合不是CI连续的，因为min和max操作符不具有这种属性(参见第21.5节)。
&nbsp;&nbsp;&nbsp;&nbsp;运算符的分析是复杂的，因为有时需要创建一个C'不连续。只要需要在表面上产生折痕，就会发生这种情况。例如，一个立方体不是Cl，因为每条边都有切线不连续。要使用C原语创建折痕，操作符必须引入C个不连续点，因此不能是Cl本身。
#### 21.1.2 距离字段、R-函数和F-Reps
&nbsp;&nbsp;&nbsp;&nbsp;距离场是关于某个物体T定义的:
$$
F(T,p)=min_{q\in T}|q-p|.
$$
&nbsp;&nbsp;&nbsp;&nbsp;F(T, p)是p到T的最短距离，因此，当p在T上时，F(T,p) = 0隐函数创建的曲面就是物体T。在T之外，返回一个非零距离。函数T可以是3d中嵌入的任何几何实体——点、曲线、曲面或实体。使用距离场的过程建模始于Ricci (Ricci, 1973);r -函数(Rvachev, 1963)在20多年后首次应用于形状建模(见夏皮罗，1994)(A. Pasko, Adzhiev, Sourin， & Savchenko, 1995)。
&nbsp;&nbsp;&nbsp;&nbsp;R函数或Rvachev函数是当且仅当其中一个参数的符号改变时，其符号才会改变的函数;也就是说，它的符号完全由它的参数决定。r -函数为实函数的布尔组合提供了一个健壮的理论框架，允许构造C”CSG算子(Shapiro, 1988)。这些CSG算符可以简单地通过在结果上添加固定偏移量来创建混合算符(a . Pasko et al.， 1995)。虽然这些混合函数在技术上不再是r -函数，但它们具有大多数理想的性质，并且可以自由地与r -函数混合，以创建复杂的层次模型(Shapiro, 1988)。这些基于r函数的混合运算符和CSG运算符称为r运算符(参见第21.4节).Hyperfun系统(Adzhiev et al.， 1999)基于f -rep(函数表示)，隐式曲面的另一个名称。该系统使用一种类似c语言的过程语言来描述多种类型的隐式曲面。
#### 21.1.3 级别集
&nbsp;&nbsp;&nbsp;&nbsp;通过规则网格(Barthe, Mora, Dodgson， & Sabin, 2002)或自适应网格(Frisken, Perry, Rockwood， & Jones，2000)。这正是多边形化算法在水平集的情况下所做的;此外，除了构建多边形外，网格还可以用于各种其他用途。f的离散表示通常是通过对连续函数进行有规律的抽样来得到的。例如，采样函数可以由其他体积模型表示定义(V. V. Savchenko。Pasko, Sourin， & Kunii, 1998)。数据也可以是使用三维成像技术采样的物理对象。离散体数据通常与水平集方法(Osher & Sethian, 1988)一起使用，该方法定义了一种使用依赖于曲率的速度函数动态修改数据结构的方法。基于水平集的交互建模环境已经被定义(Museth, Breen, Whitaker， & Barr, 2002)，尽管水平集只是使用隐式场的离散表示的一种方法。人们还探索了使用标准隐式曲面技术交互式定义离散表示的方法(Baerentzen & Christensen, 2002)。
&nbsp;&nbsp;&nbsp;&nbsp;使用离散数据结构的一个关键优点是，它能够作为由势定义的所有各种卷模型的统一方法场(离散与否)(V. V. Savchenko等人，1998年)。将任意连续函数转换为离散表示引入了如何重构连续函数的问题，这是附加建模操作和结果势场可视化的综合目的所需要的。这个问题的一个众所周知的解决方案是使用卷积算子应用一个滤波器g(见第9章)。滤波器的选择是由重构所需的属性所指导的，许多滤波器已经被探索过(Marschner & Lobb，1994)。突出的一点是，在所选滤波器的效率和结果重建的平滑性之间通常有一个权衡;参见第21.9节。
&nbsp;&nbsp;&nbsp;&nbsp;为了实现交互，一个离散系统必须限制网格的大小相对于可用的计算能力。这反过来又限制了建模者包含高频细节的能力。此外，平滑三二次滤波器使它不可能包括锐利的边缘，如果他们需要的话。这个问题的部分解决方案是使用自适应网格，尽管任何离散表示都有局限性。在(Schmidt, Wyvill， & Galin, 2005)中使用离散网格作为代表BlobTree节点的缓存。本文中的网格用于快速原型，位置用三线性插值，梯度值用更慢、更精确的三二次插值，因为眼睛对梯度误差的观察比位置误差更敏锐。
#### 21.1.4变分隐曲面
&nbsp;&nbsp;&nbsp;&nbsp;通常需要将采样数据转换为隐式表示。变分隐式曲面使用全局支持基函数的加权和插值或近似一组点(V. Savchenko, Pasko, Okunev， & Kunii, 1995;Turk & O'Brien, 1999;卡尔等，2001;Turk & O'Brien, 2002)。这些径向对称基函数应用于每个样本点。这种曲面的连续性取决于基函数的选择。C2薄板样条是最常用的(Turk & O'Brien, 2002;Carr et al.， 2001)。与Blinn的指数函数(见图21.2)一样，该函数是无界的，由此得到的变分隐曲面也是无界的。
&nbsp;&nbsp;&nbsp;&nbsp;如果字段是全局C2，则不能定义折痕;?然而，各向异性基函数可以用来产生变化更快的场，并可能出现折痕(Dinh, Slabaugh， & Turk, 2001)。在适当的尺度下，表面仍然是光滑的。光滑场意味着自交不会发生，因此卷总是定义良好的。薄板样条保证全局曲率最小化(Duchon, 1977)。变分插值具有许多三维建模所需的特性;然而，控制产生的表面可能是困难的。
&nbsp;&nbsp;&nbsp;&nbsp;变分隐式曲面也可以基于紧支持的径向基函数(cs - rbf)来减少变分插值技术的计算成本(Morse, Yoo, Rheingans, Chen， & Subramanian, 2001)。每个CS-RBF只影响一个局部区域，因此计算f(p)只需要在p的某个小邻域内求基函数的值。与全局支持的对应项一样，得到的字段是Ck，不支持折痕，也不会发生自相交每个基函数的局部支持导致一个有界全局域。这也保证了额外的等值线将会出现，正如许多研究人员所指出的那样(Ohtake, Belyaev， & Pasko, 2003;路透社,2003).
#### 21.1.5卷积曲面
&nbsp;&nbsp;&nbsp;&nbsp;由Bloomenthal和Shoemake (Bloomenthal & Shoemake, 1991)介绍的卷积曲面是通过将几何骨架S与核函数h进行卷积得到的。因此，空间中任意位置的值由骨架上的积分定义:
$$
f(p)=\int_Sg(r)h(p-r)dr.
$$
&nbsp;&nbsp;&nbsp;&nbsp;任何有限支持函数都可以作为h;参见(Sherstyuk, 1999)对不同内核的详细分析。
&nbsp;&nbsp;&nbsp;&nbsp;与骨架原语一样，卷积曲面也有界域。Blinn的“Blobby molecules”是卷积曲面的最简单形式(J. Blinn, 1982);在本例中，骨架仅由点组成。这个想法被Bloomenthal扩展到包括直线、圆弧、三角形和多边形骨架(Bloomenthal & Shoemake, 1991)。它们表示1D和2D原语;3D原语将在随后的Bloomenthal(Bloomenthal，1995）讨论。
&nbsp;&nbsp;&nbsp;&nbsp;卷积曲面的组合是由底层几何骨架的组成定义的，它的优点是消除了在使用相加混合组合多个骨架基元时容易出现的隆起。由复合骨架卷积产生的曲面没有隆起，如图21.4所示，即使复合骨架，场也是连续的Ton是非凸的。卷积曲面与骨架的凸部分偏移一定距离，但沿骨架的凹部分产生圆角。
&nbsp;&nbsp;&nbsp;&nbsp;图21.5显示了一个将骨骼元素进行卷积以构建复杂模型的示例。手模型包含14个原语。
#### 21.1.6定义骨架原语
&nbsp;&nbsp;&nbsp;&nbsp;正如我们将在接下来的章节中看到的，渲染隐式模型需要找到大量点的场值和梯度。我们需要距离来提供给(21.2)式，梯度对于寻找根和照明计算都很有用。为图21.2的衰减滤波函数提供距离是计算到骨架原语的最近距离的问题，对于点原语来说很简单，但对于更复杂的几何形状来说就有点棘手了。线段原语(AB)可以定义为绕着具有半球形端盖的直线的圆柱体(参见图21.6)。点Po位于f(Po) = iso和f(P) = 0的平面上，因为它不受直线原语的影响。从某点P到直线的距离可以通过简单地投影到直线AB上并计算垂直距离，例如CPb);这可以在因为A、Po和B都是已知的:
$$
\vec{AC} = \vec AB\frac{\vec {AP_0}\cdot \vec{AB}}{||AB||^2}
$$
&nbsp;&nbsp;&nbsp;&nbsp;图21.6中P2的值为> O，因为P2位于半球端帽内，可以单独检查。这种想法的变体可以定义具有不同半径的端帽的原语，生成有趣的锥形。一个例子如图21.7所示。
&nbsp;&nbsp;&nbsp;&nbsp;已经描述了各种各样的几何骨架，原则上，它只是简单地定义从某一点到骨架的距离和在p点的梯度的问题。例如，三角形的偏移面可以由三角形的顶点和半径r定义。实现这一点的一个简单方法是使用线段原语来描述连接顶点的边界圆柱(半径r)。从三角形内的点q到其中一个线段原语的边界域的距离作为到三角形平面的垂直距离返回。其他例子包括由圆和厚度参数定义的隐式圆盘，也由圆和截面半径(或内圆和外圆半径)定义的环面，圆盘和高度的圆锥体，圆角立方体等(见图21.8)。
***
### 21.2渲染
&nbsp;&nbsp;&nbsp;&nbsp;建模方法，如参数曲面，有助于可视化，因为很容易在表面上的点上迭代，可以直接从定义方程中找到;例如(z, y) = (cos θ， sin9)， 0 E[0,2)产生一个圆。
&nbsp;&nbsp;&nbsp;&nbsp;有两种技术通常用于渲染隐式表面:射线追踪和表面平铺。在实践中，设计人员希望快速可视化隐式表面模型，为了交互目的而牺牲质量。原型算法一直关注于生成一个可以在现代工作站上实时渲染的多边形网格。寻找最接近所需表面的多边形网格称为多边形化或表面平铺。对于动画或最终的可视化，质量比速度更重要，直接追踪隐式表面而不先多边形会产生很好的结果。
&nbsp;&nbsp;&nbsp;&nbsp;如前所述，寻找隐式曲面需要在空间中搜索以找到满足f(p) = 0的点。执行这样的搜索有两种主要的方法:空间分区——将空间划分为可管理的单元，如立方体，和非空间分区，如行进三角形(Hartmann, 1998;Akkouche & Galin, 2001)和收缩包装算法(van Overveld & Wyvill, 2004)。
&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们将描述原始的空间划分算法，并将其留给读者去探索更高级的方法。该算法与网格细化的后处理(见第12章)和缓存一起，为在现代工作站上交互查看隐式模型提供了一种方法。
***
### 21.3空间划分
#### 21.3.1穷举搜索
&nbsp;&nbsp;&nbsp;&nbsp;用于平铺隐式曲面的基本三次空间划分算法首次发表于(Wyvill等人，1986年)，一个面向体积可视化的类似算法被称为移动立方体(Lorensen & Cline, 1987年)。从那以后有了许多改进和扩展。
&nbsp;&nbsp;&nbsp;&nbsp;寻找隐式曲面的第一个方法可能是将空间均匀地细分为立方体单元格的规则晶格，并为每个顶点计算一个值。每个单元格都被一组最接近该单元格中所包含的表面部分的多边形所取代。这种方法的问题是，许多细胞将完全在体积外或完全在体积内;因此，许多不包含表面部分的细胞被加工。对于大型网格数据，这可能非常耗时和占用内存。
&nbsp;&nbsp;&nbsp;&nbsp;为了避免存储整个网格，基于(Wyvill等人，1986)中使用的数据结构，哈希表用于仅存储包含曲面的一块的多维数据集。工作软件发表在Graphics Gems IV (Bloomenthal，1990)。算法基于数值延拓;它从一个种子立方体开始，该立方体与曲面的一部分相交，并根据需要构建邻近的立方体来跟随曲面。
&nbsp;&nbsp;&nbsp;&nbsp;该算法分为两部分。在第一部分中，发现立方体单元包含表面，在第二部分中，每个立方体都被三角形取代。算法的第一部分由一个立方体队列驱动，每个立方体都包含曲面的一部分;算法的第二部分是表驱动的。
#### 21.3.2算法说明
&nbsp;&nbsp;&nbsp;&nbsp;以下是该算法的快速概述:
+ 将空间划分为立方体素;
+ 寻找表面，从骨架元素开始;
+ 向队列中添加体素，标记其访问过;
+ 搜索邻居;
+ 完成后，将体素替换为多边形。
  
&nbsp;&nbsp;&nbsp;&nbsp;首先，空间被细分为一个立方晶格，下一个任务是找到一个包含部分表面的种子立方体。曲面内部的立方体顶点u的字段值为t >= iso曲面外部的顶点的字段值为$U_i <iso$;因此，具有每种类型顶点之一的边将与曲面相交。我们称之为相交边。与第一个原语最近的立方体顶点处的字段值可以通过按式(21.3)计算原语贡献的总和来求值，尽管也可以使用其他运算符，稍后将看到。我们将假设f(to) > iso，这表明vo位于固体内。iso的值由用户选择;一个例子是，当使用软衰减函数时，iso = 0.5，它具有一些对称属性，导致良好的混合效果(参见图21.3)。沿着一个轴的顶点依次求值，直到值u;找到$U_i <iso$。包含相交边的立方体是种子立方体。
&nbsp;&nbsp;&nbsp;&nbsp;检查种子立方体的邻居，并将那些包含至少一条相交边的邻居添加到准备处理的队列中。要处理一个立方体，我们要检查每个面。如果任何边界具有相反符号的顶点，则曲面将通过该面，并且必须处理该面邻居。当这个过程对所有的面都完成后，算法的第二阶段应用于立方体。如果曲面是封闭的，那么最终将重新访问一个多维数据集，并且不会发现更多未标记的邻居，搜索算法将终止。处理多维数据集包括将其标记为已处理并处理其未标记的邻居。那些包含相交边缘的被处理，直到整个表面被覆盖(见图21.10)。
&nbsp;&nbsp;&nbsp;&nbsp;每个立方体都由一个标识顶点索引，我们将其定义为左下角的远角(即具有最低(r, y, 2)坐标值的顶点(参见图21.11))。对于曲面内的每个顶点，相应的位将被设置成8位表中的地址(参见图21.11和节21.3.3)。
&nbsp;&nbsp;&nbsp;&nbsp;标识顶点由整数i, j, k寻址，从立方体的(z, y, z)坐标位置计算，如r = side* i，其中side是立方体的大小。每个立方体的标识顶点可能出现在多达8个其他立方体中，并且多次存储这些顶点是低效的。因此，顶点存储在一个链散列表中。因为大部分空间不包含表面的任何部分，所以只有访问过的立方体才会被存储。在哈希表中为每个顶点找到隐式函数值。
&nbsp;&nbsp;&nbsp;&nbsp;对表面的拓扑结构一无所知，因此必须从每一个原语开始搜索，以避免错过表面上任何不连接的部分。标量可用于缩放原语的影响。如果标量可以小于零，那么就可以沿着一个轴搜索而不找到相交的边。在这种情况下，必须进行更复杂的搜索才能找到种子立方体(Galin & Akkouche, 1999)。
##### 数据结构
&nbsp;&nbsp;&nbsp;&nbsp;哈希表项包含五个值:
+ 标识顶点的i、j、k格索引(见图21.11);
+ f，标识顶点的隐式函数值;
+ 布尔值，指示是否已访问此多维数据集。
  
&nbsp;&nbsp;&nbsp;&nbsp;哈希函数通过从i、j、k中选择一些位并将它们进行算术组合来计算哈希表中的地址。例如，5个最低有效位生成一个表的15位地址，该表必须有长度215股。这样的哈希函数可以在c预处理器中整洁地实现如下:
```
#define NBITS 5
#define BMASK 037
#define HASH(a,b,c) (((a&BMASK)<<NBITS|b&BMASK)
<<NBITS|c&BMASK)
#define HSIZE 1<<NBITS*3
```
&nbsp;&nbsp;&nbsp;&nbsp;队列(FIFO列表)用作临时存储来标识要处理的邻居。算法从一个标记为已访问的种子立方体开始，并将其放在队列中。队列上的第一个多维数据集被退出队列，它的所有未访问的邻居都被添加到队列中。如果每个立方体包含部分曲面，则处理它并将其传递到算法的第二阶段。然后对队列进行处理，直到空为止。
#### 21.3.3多边形化算法
&nbsp;&nbsp;&nbsp;&nbsp;算法的第二阶段独立地处理每个立方体。单元格被一组三角形所取代，这组三角形与穿过单元格的表面部分的形状最匹配。该算法必须决定如何多边形细胞给定隐函数值在每个顶点。这些值将为正或负(即小于或大于iso-value)，为立方体的8个顶点提供256个正或负顶点的组合。256个条目的表格提供了每个三角形中使用的正确顶点(图21.12)。例如，条目4(00000100)指向第二个表，该表记录了绑定交叉边的顶点。在本例中，顶点2位于曲面((V2) >= isu)内部，因此，我们将绘制一个三角形，该三角形包含曲面上与(V2, VO)、(V2, V3)和(V2, V6)边界相交的点，如图21.13所示。
##### 求立方体-曲面交点
&nbsp;&nbsp;&nbsp;&nbsp;图21.13显示了一个立方体，其中顶点V2在曲面内部，所有其他顶点都在曲面外部。与曲面的相交出现在如图所示的三条边上。曲面与V2 - Ve相交于A点，最快但不准确的计算A的方法是使用线性插值:
$$
\frac{f(A)-f(V_2)}{f(V_6)-f(V_2)}=\frac{|A-V_2|}{side}.
$$
&nbsp;&nbsp;&nbsp;&nbsp;一边如果立方体的边为1,f(A)的求等值值为0.5，则
$$
A=V_3+\frac{0.5-f(V_2)}{f(V_6)-f(V_2)}.
$$
&nbsp;&nbsp;&nbsp;&nbsp;这对于静态图像很有效，但是在动画中帧与帧之间的误差会非常明显。应该采用一种寻找根的方法，如假根法。这变得计算成本更高，因为需要梯度来评估交点。在渲染的表面点也需要渐变。对于许多类型的原语，使用p周围的样本点来找到一个数值逼近更简单，如
$$
\nabla f(\mathbf p) =\left ( \frac{f(\mathbf p+\Delta x)-f(\mathbf p)}{\Delta x},\frac{f(\mathbf p+\Delta y)-f(\mathbf p)}{\Delta y},
\frac{f(\mathbf p+\Delta y)-f(\mathbf p)}{\Delta z}
\right).
$$
&nbsp;&nbsp;&nbsp;&nbsp;根据经验，A的合理值是0.01×边，其中边是立方体边的长度。
&nbsp;&nbsp;&nbsp;&nbsp;为了制造一个网格，而不是一组独立的三角形，第二个哈希表可以维护所有相交边的列表。因为每个立方体边缘最多由四个邻居共享，所以边缘哈希表防止了曲面-立方体边缘相交计算的重复。哈希地址可以从与顶点相同的哈希函数中派生出来(应用于边缘端点)。
#### 21.3.4抽样问题
&nbsp;&nbsp;&nbsp;&nbsp;当一个面(或立方体)的相对角具有相同的符号，而面上的另一对顶点具有相反的符号时，就会出现歧义(参见图21.14)。在面中心采集的样本将提供线索，以确定这个立方体是两个表面的交汇处还是一个马鞍。应该明确的是，空间网格在每个顶点存储隐式函数的样本。如果函数恰好在一个单元格内发生了很大的变化，多边形表示将不会显示这种变化(参见图21.15)。除非对曲面的曲率有所了解，否则不能仅通过采样来解析曲面。(Kalra & Barr, 1989)对这一话题进行了很好的讨论。
&nbsp;&nbsp;&nbsp;&nbsp;通过将立方单元格细分为四面体，可以避免这种模糊性问题(而不是采样不足问题)。四面体可以被明确地多边形化。因为每个四面体中有四个顶点，一个包含16个条目的表将提供正确的三角形信息。缺点是将生成大约两倍数量的多边形。
##### 细分立方体
&nbsp;&nbsp;&nbsp;&nbsp;不需要额外的单元顶点，一个立方体可以被分解成五个或六个四面体，如图21.16所示。这些分解在立方体面上引入对角线，并保持对角线之间的方向一致邻，六分解为佳。引入对角线边缘比直接用三角形替换每个立方体产生更高的分辨率曲面。分解成四面体和用三角形替换四面体是快速的、表驱动的算法，它产生拓扑上一致的网格。
#### 21.3.5细胞多边形化
&nbsp;&nbsp;&nbsp;&nbsp;统一空间划分的使用产生了两个明显的问题。该算法输出的三角形的大小不适应曲面的曲率，需要进一步的采样来解决歧义，其中立方单元替换为多边形单元.Bloomenthal (Bloomenthal, 1988)开发了一种基于八叉树的spave sublivision alguritlun，它确实适应曲面的曲率。单元被细分为八个分区，使用受限八叉树方案避免了裂缝，即相邻的单元不能有超过一个细分级别的差异。这确实减少了生成的多边形数量，但只有当表面的平坦区域恰好完全落在适当的区域内时，才能充分利用大型单元格的优势。实践证明，该算法比统一体素算法速度要慢得多，实现起来也更加复杂。

***
### 21.4关于混合的更多信息
&nbsp;&nbsp;&nbsp;&nbsp;第21.1节说明了当字段值相加时可以进行混合。Ricci，在他的里程碑式的论文(Ricci, 1973)中，描述了超椭圆混合。已知FA和FB两个函数，之前我们简单求出其隐值为Fiotal = FA+ FB。我们可以将这个更一般的混合算符表示为Ao b。里奇混合的定义为:
$$
f_{A\circ B}=(f_A^n+f_B^n)^{\frac{1}{n}}. \tag{21.4}
$$
&nbsp;&nbsp;&nbsp;&nbsp;有趣的是，我们可以指出以下的属性:
$$
\lim_{n \to +\infty}(f_A^n+f_B^n)^{\frac{1}{n}}=max(f_A,f_B),\\
\lim_{n\to{-\infty}}(f_A^n+f_B^n)^{\frac{1}{n}}=min(f_A,f_B).
$$
&nbsp;&nbsp;&nbsp;&nbsp;标准共混算子+被证明是n = 1的超椭圆共混的一个特例。当n从1变化到无穷时，它会在混合a + B和并集a U B之间创建一组混合插值(参见图21.17)。图21.27显示节点是二进制或一元的;事实上，使用上述公式可以很容易地将二元节点扩展到n元节点。
&nbsp;&nbsp;&nbsp;&nbsp;Ricei算子的强大之处在于它们在所有可能的隐体积的空间上的运算下是封闭的，这意味着一个算子的应用仅仅产生了另一个定义另一个隐体积的标量场。这个新字段可以与其他字段组合，同样使用里奇运算符。式(21.4)总是能得到两个隐式体积的精确并集，不管它们有多复杂。与将布尔CSG操作应用于B-rep曲面的困难相比，隐式体积实体建模非常简单。
&nbsp;&nbsp;&nbsp;&nbsp;根据Pasko的函数表示(A. Pasko et al.， 1995)，可以定义另一个广义混合函数:
$$
f_{A\circ B}=\left( f_A+f_B+a\sqrt{f_A^2+f_B^2}\right)(f_A^2+f_B^2)^{\frac{n}{2}}
$$
&nbsp;&nbsp;&nbsp;&nbsp;当E[- 1,1]从-1到1变化时，它创建一组混合插值并算子和交集算子。然而，该算子不再是结合律，这与n-ary算子的定义是不相容的。

***
### 21.5构造实体几何
&nbsp;&nbsp;&nbsp;&nbsp;隐式模型常被称为隐式曲面;然而，它们本质上是体积模型，对于实体建模操作非常有用。利玛窦介绍了构造几何，用于根据原语上的并、交、差和混合等操作定义复杂形状(Ricci, 1973)。该曲面被认为是定义内部的半空间f(p) <1和定义外部的f(p) > 1之间的边界。这种最初的实体建模方法演变成了构造实体几何或CSG (Ricci, 1973;Requicha, 1980)。
CSG通常根据二叉树自底向上计算，用低次多项式原语作为叶节点和表示布尔集操作的内部节点。这些方法很容易适用于隐式建模，在骨骼隐式曲面的情况下，布尔集运算联合Umax、交集Omin和差分minmax定义如下(Wyvill，Galin， & Guy， 1999）：
$$
\begin{aligned}
\cup_{max} \quad f &=max_{i=0}^{k-1}(f_i),\\ \tag{21.5}
\cap_{min} \quad f &= min_{i=0}^{k-1}(f_i),\\
\setminus {minmax} \quad f &= min\left(f_0,2*ios-max_{j=1}^{k-1}(f_j)\right).\\
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;里奇算符如图21.18所示，用于点原语A和b。对于联合(左下)，联合内所有点的场将是fA()和fB()中较大的。对于交点(中心)，标记为P的区域内的点的值min (fA(P1)， fB(P1)) = 0，因为b的贡献在其影响范围之外将为零。同样，对于标记为P的区域，(A的影响为零，即最小)只留下正的交集区域。Difference的工作原理类似于使用三者中的iso-value标记区域(P)如下:
$$
\begin{aligned}
f(P_0)&= min(f_B(P_0),2*iso-f_A(P_0))\\
&= min([iso,1],[2*iso-1,iso])\\ 
&= [2*iso-1,iso]<iso\\
f(P_1)&= min(f_B(P_1),2*iso-f_A(P_1))\\
&= min([0,iso],[2*iso-1,iso])<iso\\ 
f(P_2)&= min(f_B(P_2),2*iso-f_A(P_2))\\
&= min([iso,1],[iso,2*iso])\geq iso\\ 
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;CSG算子产生折痕，即CI不连续。例如，min()算符(式(21.5))在fi(p) fa(p)的所有点上创建C1不连续。当应用到两个球体上时，由这个并算符产生的不连续在表面上导致了一个折痕，如图21.18所示，这是预期的结果。不幸的是，不连续延伸到表面外的场中，这在这张照片中是看不到的。如果混合然后应用到联合的结果，在现场的cl -不连续平面产生一个着色不连续(图21.19)。
&nbsp;&nbsp;&nbsp;&nbsp;这个问题在一定程度上是可以避免的(G. Pasko, Pasko, Ikeda， & Kunii, 2002)，并且已经开发出在所有点都是Cl的CSG操作符.其中 f1（p） = f2（p） = iso （Barthe， Dodgson， Sabin， Wyvill， & Gaildrat，2003).
***
### 21.6扭曲
&nbsp;&nbsp;&nbsp;&nbsp;通过扭曲曲面附近的空间来扭曲曲面形状的能力是一种有用的建模工具。翘曲是一个连续函数w(r, y, 2)它将R3映射到R3上。在描述自由形式变形时，Sederberg为翘曲提供了一个很好的类比(Sederberg & Parry, 1986)。他认为，扭曲的空间可以被比作一个清晰、灵活、可塑的平行六面体，要扭曲的物体就嵌入其中。一个扭曲元可以通过对隐式方程应用某种扭曲函数w(p)来定义:
$$
f_i(x,y,z)=g_i\circ d_i \circ w_i(x,y,z). \tag{21.6}
$$
&nbsp;&nbsp;&nbsp;&nbsp;一个扭曲的元素可以通过到它的骨架d;(z, y, z)的距离，它的衰减滤波函数gi(r)，以及最终它的扭曲函数w;(z, y,x)来完全表征。在隐式表面上显示或执行操作必须找到f(P)的值。首先，P被warp函数变换为一个新的点Q, f(Q)被返回来代替f(P)。在图21.20中，返回的不是某个点f(Q)的隐式值，而是f(P)的值。在这种情况下，返回iso值，隐式曲面(2D曲线)通过Q而不是p，因此圆被扭曲成椭圆。
&nbsp;&nbsp;&nbsp;&nbsp;Barr引入了全局和局部变形的概念，通过对参数曲面的扭转、锥度和弯曲操作(Barr, 1984)。变形可以被嵌套以产生如图21.27所示的模型。从概念上讲，它们很容易应用于隐式曲面，如式(21.6)所示。
&nbsp;&nbsp;&nbsp;&nbsp;注意，法线不能用与扭曲点类似的方式计算。这个问题类似于关于实例化的第13.2节中概述的问题。在这种情况下，虽然如(Barr, 1984)中所建议的使用雅可比矩阵可以得到精确的结果，但法线最容易用式(21.3.3)近似。巴尔翘曲将在下面几节中描述。
#### 21.6.1 Twist
&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，对于三个混合隐式圆柱体，捻度绕z轴e(见图21.21)，并施加一个捻度翘曲。绕z的扭转表示为
$$
w(x,y,z)= \left\{
\begin{matrix}
x*\cos(\theta(z))-y*\sin(\theta(z)) \\ x*\sin(\theta(z))-y*\cos(\theta(z)\\z 
\end{matrix}
\right\}
$$
### 21.6.2 锥
&nbsp;&nbsp;&nbsp;&nbsp;锥度沿一个主轴施加。线性圆锥被证明是最有用的，尽管二次圆锥和三次圆锥很容易实现。例如，沿y轴的线性锥度涉及改变r和z坐标。(见图21.22)y在ymax和ymin之间取一个线性比例:
$$
s(y)=\frac{y_{max}-y}{y_{max}-y_{min}}\qquad w(x,y,z)=\left\{
\begin{matrix} s(y)x\\ y\\ s(y)z \end{matrix}
\right\}
$$
&nbsp;&nbsp;&nbsp;&nbsp;弯曲也应用在一个主轴上。(见图21.23)对于下面的弯曲例子，弯曲率是k，单位是单位长度的弧度，弯曲的轴是
$$
w(x,y,z)= \left\{
\begin{matrix}
-\sin(\theta)* (y-1/k)+x_0)\\ \cos(\theta)*(y-1/k)+1/k\\ z 
\end{matrix}
\right\}
$$
#### 21.7精确接触建模
&nbsp;&nbsp;&nbsp;&nbsp;精确接触建模(PCM)是一种在接触情况下变形隐式曲面原语的方法，同时保持具有C’连续性的精确接触面(Gascuel, 1993)。PCM很重要，因为它是显示模型如何对其环境做出反应的一种简单而自动的方法。对于非隐式方法，这不是那么容易做到的(参见图21.24)。
&nbsp;&nbsp;&nbsp;&nbsp;PCM是通过包含一个变形函数s(p)来实现的，该函数修改每个点返回的字段值。对于每一对对象，首先使用边界框测试检测碰撞。一旦确定可能发生碰撞，就应用PCM。计算局部几何变形项s，并将其加到隐函数f，。将碰撞物体的体积分为相互穿透区和变形区。应用si的结果是相互渗透区域被压缩，因此保持接触而不发生相互渗透(见图21.25)。si的影响在传播区域内衰减到零，这样两个区域外的体积就不会变形。
&nbsp;&nbsp;&nbsp;&nbsp;给定两个生成场f1(p)和f2(p)的骨架单元，每个单元周围的表面计算为
$$
f_1(p)+s_1(p) = 0,
f_2(p)+s_2(p) = 0.
$$
&nbsp;&nbsp;&nbsp;&nbsp;我们需要生成两个元素共同的曲面(图21.25中的虚线)，也就是说，它们在相互渗透区域中共享某个p的解:
$$
s_1(p)+f_1(p) = iso,\tag{21.7}
s_2(p)+f_2(p) = iso.
$$
&nbsp;&nbsp;&nbsp;&nbsp;h的值为M，。s的当前最小值;互穿区为负值，记为Simin，其中M = -0isimin。因此，一个物体将在穿透区域被压缩，并将在传播区域膨胀。h的方程由两个三次多项式组成，在r = ri/2处连接，其中斜率为零:
$$
\begin{aligned}
c &=\frac{4(w_ik-4M_i)}{w_i^3},\\
d &=\frac{4(3w_i-w_ik)}{w_i^2},\\
h_i(r)&=cr^3+dr^2+kr \qquad if \quad r\in[0,w_i/2],\\
h_i(r)&=\frac{4M_i}{w_i^3}(r-w_i)^3(4r-w_i)^3 \qquad if \quad r\in[w_i/2,w_i], 
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;当我们从互穿区移动到传播区时，我们希望有cl -连续性。因此，图21.26中的h(0) = k为s的方向导数;在接口处(图21.25中标记为po)。由式(21.7)可知，互渗区域si = fi，则:
$$
k=||\nabla(f_i,p_0)||
$$
&nbsp;&nbsp;&nbsp;&nbsp;PCM只是一个适当变形表面的近似，但它是一个有吸引力的算法，因为它的简单。
***
### 21.8 BlobTree
&nbsp;&nbsp;&nbsp;&nbsp;BlobTree是一种使用树结构的方法，该树结构扩展了CSG树，以包括使用骨架原语的各种混合操作(Wyvill等人，1999年)。一个具有类似功能的系统，Hyperfun项目，使用一种专门的语言来描述F-rep对象(Adzhiev等，1999)。
&nbsp;&nbsp;&nbsp;&nbsp;在BlobTree系统中，模型由结合隐式原语和运算符U(并)、n(交集)、-(差)、+(混合)、o(超椭圆混合)和w (warp)的表达式定义。BlobTree不仅是由这些表达式构建的数据结构，而且是一种可视化模型结构的方法。上面列出的操作符都是二进制的，除了warp，它是一元操作符。一般来说，使用n-ary操作符比使用二进制操作符更有效。BlobTree将仿射转换作为节点，因此它也是一个场景图和原语(例如，骨架)形成叶节点。
#### 21.8.1遍历BlobTree
&nbsp;&nbsp;&nbsp;&nbsp;一个包括Barr扭曲和CSG操作的BlobTree示例如图21.27所示。其他节点可以包括2D纹理(Schmidt, Grimm， & Wyvill, 2006)，精确的接触建模，以及动画和其他属性。
BlobTree的遍历本质上非常简单。通过多边形或射线追踪渲染对象所需要的是找到任何点的隐式值(以及相应的梯度)。这可以通过遍历树来完成。多边形化和射线跟踪算法需要计算空间中大量点上的隐式场函数。函数f(N, M)返回节点N在点M处的字段值，该值取决于节点的类型。值C和R表示搜索树的左侧或右侧分支。为了简单起见，下面的算法就像树是二叉的一样:
&nbsp;&nbsp;&nbsp;&nbsp;函数 f(N , M) :
+ 原语:f (M);
+ 翘曲： f（C（N）， w（M））;
+ 混合:f(C(N)， M) +f(R(N)， M));
+ 联合: max(f(C(N)， M)， f(R(N)， M));
+ 交集:min(f(C(N)， M)， J(R(N)， M));
+ 差值:min(f(C(N)， M)， -f(R(N)， M))。
  
&nbsp;&nbsp;&nbsp;&nbsp;如图21.28所示，一个复杂的BlobTree模型显示了许多已集成的特性。
***
### 21.9交互隐式建模系统
&nbsp;&nbsp;&nbsp;&nbsp;早期基于草图的建模系统，如Teddy (Igarashi, Matsuoka， & Tanaka, 1999)，使用用户绘制的一些笔画来推断3-空间中的多边形模型。有了更好的硬件和改进的算法，基于草图的隐式建模系统现在成为可能。Shapeshop使用隐式扫描曲面从2D用户笔画生成3D笔画，并保留了BlobTree的层次结构，不像早期系统生成同质网格(Schmidt, Wyvill, Sousa， & Jorge, 2005)。这使得用户可以通过一些简单的笔触生成任意拓扑的复杂模型。边距图显示了一个封闭绘制的笔画(图21.29)膨胀为一个隐式扫描和第二个扫描(图21.30)，使用CSG减去了一个较小的扫描对象。
&nbsp;&nbsp;&nbsp;&nbsp;使这成为可能的一个改进是一个缓存系统，它在BlobTree的每个节点上使用一个固定的隐式值的3D网格，表示通过遍历节点以下的树(Schmidt, Wyvill， & Galin，
2005)。如果需要在节点N处取某个点p的值，则可以在不遍历N以下的树的情况下返回一个值，前提是树的那部分未被改变。相反，使用插值方案(参见第9章)来寻找p的值。该方案加快了复杂blobtree的遍历速度，是使系统能够以交互速率运行的一个因素。
&nbsp;&nbsp;&nbsp;&nbsp;下一代隐式建模系统将利用硬件和软件的进步，以能够交互地处理越来越复杂的层次模型。一个更复杂的Shapeshop示例如图21.31所示。

***
### 练习
1. 在隐式曲面建模系统中，定义了衰减滤波函数
$$
f(r)=
\begin{cases}
0, &r>R,\\
1-r/R, &otherwise.
\end{cases} 
$$
R是常数。一个位于(- 1,0)的点原语和另一个位于(1,0)的点原语被渲染以显示f = 0.5的等值面。R值，即在两种情况下由该点产生的电势为零的距离，为1.5。
计算点(0,0)处和+0.5间隔处的电势，直到点(2.5,0)。画出0.5等高线和场降为零的等高线。
2. 为什么在多边形化算法中的模糊情况被认为是一个抽样问题?
3. 计算使用线性插值估计隐式曲面与立方体素相交时的误差。
4. 使用您选择的框架设计一个隐式原始函数。函数必须接受一个点作为输入，并返回一个隐式值和该点的梯度。

