*边学边翻译，督促自己不能落下，同时也留点记忆*

# <center>**第九章 图形管线**</center> 

***
&nbsp;&nbsp;&nbsp;&nbsp;前面的几章已经建立了我们所需要的数学框架来研究渲染的第二种主要方法:将对象一个一个地绘制到屏幕上或按对象顺序绘制。不像在射线追踪中，我们依次考虑每个像素并找到影响其颜色的对象，现在我们将依次考虑每个几何对象并找到它可能产生影响的像素。在图形中查找被一个几何元素占用的所有像素的过程叫光栅化，因此，对象顺序渲染也可以称为栅格化渲染。所需要的操作顺序，从对象开始，以更新图像中的像素结束，这被称为图形管道。
&nbsp;&nbsp;&nbsp;&nbsp;对象顺序呈现因其效率而获得了巨大的成功。对于大型场景，数据访问模式的管理对性能至关重要，在场景中一次访问每个几何位比反复搜索场景以检索每个像素阴影所需的对象具有显著的优势。
&nbsp;&nbsp;&nbsp;&nbsp;本章的标题表明，只有一种方法可以进行对象顺序呈现。当然，这不是真的——有两个目标截然不同的图形管道例子，一个是用于通过OpenGL和Direct3D等api支持交互渲染的硬件管道，另一个是用于电影制作的软件管道，支持RenderMan等api。硬件管道必须运行得足够快，以便对游戏、可视化和用户界面做出实时反应。制作管道必须尽可能渲染最高质量的动画和视觉效果，但是很耗时
 尽管这些不同的目标导致了不同的设计决策，但是大部分(如果不是全部的话)管道之间共享了相当多的内容，本章试图关注这些共同的基本原理，在更紧密地遵循硬件管道方面犯了错误。
在对象顺序渲染中需要完成的工作可以被组织成栅格化本身的任务，在栅格化之前对几何图形所做的操作，以及在栅格化之后对像素所做的操作。
&nbsp;&nbsp;&nbsp;&nbsp;最常见的几何操作是应用矩阵变换，如前两章所述，将定义几何图形的点从对象空间映射到屏幕空间，以便光栅化器的输入以像素坐标或屏幕空间表示。最常见的像素级操作是隐藏表面移除，它安排离观看者较近的表面出现在距离观看者较远的表面前面。许多其他操作也可以包括在每个阶段，从而实现广泛的不同渲染效果使用相同的一般过程。
&nbsp;&nbsp;&nbsp;&nbsp;为了本章的目的，我们将从四个阶段来讨论图形管道(图9.1)。几何对象从交互式应用程序或场景描述文件中被输入到管道中，并且它们总是由一组顶点描述。顶点在顶点处理阶段被操作，然后使用这些顶点的原语被发送到栅格化阶段。光栅化器将每个原语分解为许多片段，每个片段对应原语覆盖的每个像素。在片段处理阶段对片段进行处理，然后在片段混合阶段对每个像素对应的各个片段进行组合。
&nbsp;&nbsp;&nbsp;&nbsp;我们将从讨论栅格化开始，然后通过一系列示例说明几何和像素级阶段的目的。

***
### 光栅化
&nbsp;&nbsp;&nbsp;&nbsp;栅格化是对象顺序图形的中心操作，栅格化器是任何图形管道的中心。对于传入的每个原语，光栅化器有两项工作:枚举原语覆盖的像素，并在原语中插入称为属性的值——这些属性的目的将在后面的示例中清楚地说明。光栅化器的输出是一组片段，每个片段对应原语覆盖的像素。每个片段“驻留”在一个特定的像素上，并带有自己的一组属性值。
&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们将介绍栅格化，并展望如何使用它来渲染三维场景。同样的栅格化方法也用于绘图2D的线条和形状也一样，尽管使用3D图形系统来“隐藏”完成所有的2D绘图变得越来越普遍。
#### 9.1.1直线画法
&nbsp;&nbsp;&nbsp;&nbsp;大多数图形包都包含一个绘图命令，它接受屏幕坐标中的两个端点(参见图3.10)，并在它们之间绘制一条线。例如，对端点(1,1)和(3,2)的调用将打开像素(1,1)和(3,2)，并在它们之间填充一个像素。对于一般屏幕坐标端点(xo, yo)和(x1, y1)，例程应该绘制一些“合理的”像素集，近似于它们之间的一条线。绘制这样的直线是基于直线方程的，我们有两种类型的方程可以选择:隐式方程和参数方程。本节描述使用隐式线的方法。
##### 用隐式直线方程画线
&nbsp;&nbsp;&nbsp;&nbsp;使用隐式方程画线最常见的方法是中点算法(Pitteway, 1967;van Aken & Novak, 1985))。中点算法最终画出与Bresenham算法相同的线(Bresenham, 1965)，但它在某种程度上更直接。
&nbsp;&nbsp;&nbsp;&nbsp;首先要做的是找到这条直线的隐式方程，如2.7.2节所述:
$$

 f(x,y) = (y_0-y_1)x+(x_1-x_0)y+x_0Y_1-x_1y_0=0 \tag{9.1}
$$

&nbsp;&nbsp;&nbsp;&nbsp;我们假设cosx1。如果这不是真的，我们交换点，使它为真。
直线的斜率m由
$$
m=\frac{y_1-y_0}{x_1-x_0}.
$$
&nbsp;&nbsp;&nbsp;&nbsp;下面的讨论假设m E(0,1]。对于me(-00， -1)、me(- 1,0)和me (1, oo)也可以推导出类似的讨论。这四种情况涵盖了所有可能性。
&nbsp;&nbsp;&nbsp;&nbsp;对于m∈(0,1)，“下”比“上”多;例如，直线在x处比在y处移动得快。如果我们有一个y轴向下的API，我们可能会担心这是否会增加过程的难度，但事实上，我们可以忽略这个细节。我们可以忽略“上”和“下”的几何概念，因为这两种情况的代数是完全相同的。谨慎的读者可以确认，得到的算法适用于y轴向下的情况。中点算法的关键假设是我们尽可能画出最细的线，两个相连的像素没有空隙。
&nbsp;&nbsp;&nbsp;&nbsp;当直线从左端点向右移动时，只有两种可能:画一个像素与画在它左边的像素高度相同，或者画一个像素高一个像素。在端点之间的每一列像素中总是刚好有一个像素。0表示差距，2表示线太粗了。对于我们正在考虑的情况，可能在同一行中有两个像素;这条线是水平的，而不是垂直的，所以它有时会向右，有时会向上。这个概念如图9.2所示，其中显示了三条“合理的”线，每条线在水平方向上的推进比在垂直方向上的多。m E(0,1)的中点算法首先建立最左边的像素和最右边像素的列数(x值)，然后水平循环建立每个像素的行(y值)。算法的基本形式是：
```
y=y0
for x=x0 to x1 do
    draw(x,y)
    if(some condition) then
        y=y+1
```
&nbsp;&nbsp;&nbsp;&nbsp;注意z和y是整数。换句话说，“保持从左到右绘制像素，有时在这样做的时候在y方向向上移动。”关键是在if语句中建立高效的决策方法。
&nbsp;&nbsp;&nbsp;&nbsp;做出选择的一个有效方法是观察两个潜在像素中心之间的线的中点。更具体地说，刚刚绘制的像素是像素(r, y)，其在实际屏幕坐标中的中心点为(x, y)。要绘制到右边的候选像素是像素(r + 1, y)和像素(T + 1, y + 1)。两个候选像素的中心点之间的中点为(r + 1, y + 0.5)。如果这条线经过这个中点以下，我们就画底部像素，否则，我们就画顶部像素(图9.3)。
&nbsp;&nbsp;&nbsp;&nbsp;为了确定直线是高于还是低于(T+ 1,y +0.5)，我们在式(9.1)中计算f(r + 1,y +0.5)。回顾2.7.1节f(r，对于直线上的点(r, y)， f(r, y) > O对于直线一侧的点，f(r, y) < 0对于直线另一侧的点。因为-f(t, y)和f(r, y) = 0都是这条直线的完美方程，所以不能立即确定f(r, y)为正表示(t, y)在这条直线上还是在这条直线下。但是，我们可以算出来;式(9.1)中的关键项是y项(T1 - ro)y。注意(T1 - To)肯定是正的，因为T1 > To。这意味着，随着y的增加，项(T1 - To)y变大(即，更正或更负)。因此，f(z， +oo)肯定是正的，而且肯定在这条线上，这意味着在这条线上的点都是正的。
&nbsp;&nbsp;&nbsp;&nbsp;另一种看待它的方法是梯度向量的y分量是正的。在这条线上，y可以任意增加，f(r, y)必须是正的。这意味着我们可以通过填充if语句使代码更具体:
```
if f(x+1,y+0.5)<0 then 
    y=y+1
```
&nbsp;&nbsp;&nbsp;&nbsp;上面的代码将很好地用于适当斜率的直线(即，在0和1之间)。读者可以找出其他三种情况，只是在细微的细节上有所不同。
&nbsp;&nbsp;&nbsp;&nbsp;如果需要更高的效率，使用增量方法会有所帮助。增量方法试图通过重用前一步的计算来提高循环的效率。在文中提出的中点算法中，主要计算f(r + 1,y + 0.5)的取值。注意，在循环内部，在第一次迭代之后，我们要么已经计算了f(r - 1, y + 0.5)，要么已经计算了f(r - 1, y - 0.5)(图9.4)。还要注意以下关系:
$$
f(x+1,y)=f(x,y)+(y_0-y_1)\\
f(x+1,y+1)=f(x,y)+(y_0-y_1)+(x_1-x_0).
$$
&nbsp;&nbsp;&nbsp;&nbsp;这允许我们编写一个增量版本的代码:
```
y = y0
d =f(x0+1,y0+0.5)
for x=x0 to x1 do
    draw(x,y)
    if  d<0 then
        y=y+1
        d =d+(x1-x0)+(y0-y1)
    else
        d = d+(y0-y1)
```
&nbsp;&nbsp;&nbsp;&nbsp;这段代码应该运行得更快，因为与非增量版本相比，它几乎没有额外的设置成本(增量算法并不总是如此)，但它可能会累积更多的数值错误，因为f(t, y + 0.5)的求值可能由许多长行相加组成。然而，考虑到线条很少超过几千像素，这样的错误不太可能是严重的。
&nbsp;&nbsp;&nbsp;&nbsp;通过将(T1- To) + (yo - y1)和(yo - y1)作为变量存储，可以实现稍长的设置成本，但更快的循环执行。我们可能希望一个好的编译器能为我们做到这一点，但如果代码是关键的，最好检查编译的结果以确保这一点。

#### 9.1.2 三角形光栅化
&nbsp;&nbsp;&nbsp;&nbsp;我们经常想要在屏幕坐标中绘制一个2D三角形，其中的2D点p0 = (x0, y0)， p1 = (x1, y1)， p2 = (x2, y2)。这类似于画线问题，但它有自己的一些微妙之处。与绘制直线一样，我们可能希望从顶点处的值插值颜色或其他属性。如果我们有重心坐标(第2.9节)，这就很简单了。例如，如果顶点的颜色为c0、c1和c2，那么三角形重心坐标(α、β、γ)中某一点的颜色为
$$
c = \alpha C_0 + \beta C_1+\gamma c_2.
$$
&nbsp;&nbsp;&nbsp;&nbsp;这种类型的颜色插值在图形中以其发明者(Gouraud, 1971)的名字被称为Gouraud插值。
&nbsp;&nbsp;&nbsp;&nbsp;光栅化三角形的另一个微妙之处在于，我们通常是对共享顶点和边的三角形进行光栅化。这意味着我们要栅格化相邻的三角形，这样就没有小孔了。我们可以用中点来做算法画出每个三角形的轮廓，然后填充内部像素。这意味着相邻三角形沿着每条边绘制相同的像素。如果相邻的三角形有不同的颜色，图像将取决于顺序画出了两个三角形。为了避免顺序问题和消除空洞，栅格化三角光栅最常见的方法是使用约定当且仅当像素的中心在三角形内部时，像素才会被绘制;即像素中心的重心坐标都在(0,1)的区间内如果圆心正好在三角形的边缘该怎么办。在那里处理此问题的几种方法将在本节后面讨论。的关键我们观察到重心坐标可以让我们决定是否画一个像素和像素应该是什么颜色如果我们从插值的颜色顶点。因此，我们对三角形栅格化的问题归结为高效地找到像素中心的重心坐标(Pineda, 1988)。的蛮力光栅化算法：
~~~
    for all x do
        for all y do
            compute (α, β, γ) for (x, y)
            if (α ∈ [0, 1] and β ∈ [0, 1] and γ ∈ [0, 1]) then
                c = αc0 + βc1 + γc2
                drawpixel (x, y) with color 
~~~
&nbsp;&nbsp;&nbsp;&nbsp;算法的其余部分将外部循环限制在更小的候选像素集上，并使重心计算高效。
&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过找到三个顶点的边界矩形并只在该矩形上循环以绘制候选像素来增加简单的效率。
我们可以用式(2.32)计算重心坐标。这就产生了算法
~~~
    xmin = floor(xi)
    xmax = ceiling(xi)
    ymin = floor(yi)
    ymax = ceiling(yi)
    for y = ymin to ymax do
        for x = xmin to xmax do
            α = f12(x, y)/f12(x0, y0)
            β = f20(x, y)/f20(x1, y1)
            γ = f01(x, y)/f01(x2, y2)
            if (α > 0 and β > 0 and γ > 0) then
                c = αc0 + βc1 + γc2
                drawpixel (x, y) with color c
~~~
&nbsp;&nbsp;&nbsp;&nbsp;其中fij为式(9.1)给出的具有相应顶点的直线.
$$
    f_{01}(x, y)=(y_0 − y_1)x + (x_1 − x_0)y + x_0y_1 − x_1y_0,\\
    f_{12}(x, y)=(y_1 − y_2)x + (x_2 − x_1)y + x_1y_2 − x_2y_1,\\
    f_{20}(x, y)=(y_2 − y_0)x + (x_0 − x_2)y + x_2y_0 − x_0y_2
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，我们用α &gt交换了检验α∈(0,1);0等等，因为如果α β γ都是正的，我们知道它们都小于1，因为α +β + γ = 1。我们也可以只计算三个重心变量中的两个然后从这个关系中得到第三个，但不清楚这是否节省了计算量一旦算法是增量式的，这是可能的，就像在线图算法;α β和γ的每一次计算都是对form f(x, y) = Ax + By + c在内部循环中，只有x改变了，它也改变了由一个。注意f(x + 1, y) = f(x, y) + a，这是增量的基础算法。在外层循环中，f(x, y)的求值变化为f(x, y + 1)，所以可以达到类似的效率。因为α β和γ的变化是常数在循环中递增，颜色c也是，所以这可以被递增为好。例如，像素(x + 1, y)的红色值与红色值不同像素(x, y)的常数值，可以预先计算。一个关于颜色插值的三角形如图9.5所示。
##### 三角形边缘像素的处理
&nbsp;&nbsp;&nbsp;&nbsp;我们还没有讨论如何处理中心正好位于三角形边缘的像素。如果一个像素恰好在三角形的边缘上，则
&nbsp;&nbsp;&nbsp;&nbsp;如果有的话，也在相邻三角形的边缘上。没有明显的方法将像素分配给一个三角形或另一个三角形。最糟糕的决定是不绘制像素，因为两个三角形之间会产生一个洞。更好的，但仍然不是很好，是让两个三角形都画像素。如果三角形是透明的，这将导致双色。我们很想把像素归给其中一个三角形，我们希望这个过程很简单;选择哪个三角形并不重要，只要选择是明确的.
&nbsp&nbsp;&nbsp;&nbsp;一种方法是注意到任何屏幕外的点都确切地位于一个点上.共享边的边就是我们要画的那条边。有两个重叠三角形，不在边上的顶点是在每条边的相对边上其他。正好有一个顶点会在这条边的同一边屏幕外点(图9.6)。这是测试的基础。如果数字p与q有相同符号的可实现测试pq和gt;0，非常在大多数环境中都是有效的。
&nbsp;&nbsp;&nbsp;&nbsp;注意，测试并不完美，因为通过边缘的线也可能经过屏幕外的点，但我们至少大大减少了数量有问题的情况下。使用哪个屏幕外点是任意的，并且(x, y) =(−1，−1)是一个很好的选择。我们需要为a的情况增加一张支票精确地指向一条边。我们不希望这张支票被承兑用例，它们是完全内部或外部的测试。建议:
~~~
xmin = floor(xi)
xmax = ceiling(xi)
ymin = floor(yi)
ymax = ceiling(yi)
fα = f12(x0, y0)
fβ = f20(x1, y1)
fγ = f01(x2, y2)
for y = ymin to ymax do
    for x = xmin to xmax do
        α = f12(x, y)/fα
        β = f20(x, y)/fβ
        γ = f01(x, y)/fγ
        if (α ≥ 0 and β ≥ 0 and γ ≥ 0) then
            if (α > 0 or fαf12(−1, −1) > 0) and
            (β > 0 or fβf20(−1, −1) > 0) and
            (γ > 0 or fγf01(−1, −1) > 0) then
            c = αc0 + βc1 + γc2
            drawpixel (x, y) with color c
~~~
&nbsp;&nbsp;&nbsp;&nbsp;我们可能期望，只有当我们对两个三角形使用完全相同的直线方程时，上面的代码才能够消除空洞和双对齐。事实上,只有当两个共享顶点在每个三角形的绘制调用中具有相同的der或der时，直线方程才相同。否则，方程可能会翻转符号。这可能是一个问题，取决于编译器是否更改的顺序操作。因此，如果需要一个健壮的实现，编译器的细节算术单元可能需要检查。必须小心地对上面的pseudo docode中的前四行进行编码，以处理边缘恰好命中的情况像素中心。
&nbsp;&nbsp;&nbsp;&nbsp;除了适应增量实现之外，还有其他方法几个潜在的早期退出点。例如，如果α是负的，就没有必要来计算β或γ。虽然这可能会导致速度的提高，但分析是这总是一个好主意;额外的分支可以减少流水线或并发性可能会降低代码的速度。因此，和往常一样，测试任何看起来有吸引力的优化如果代码是临界段。
&nbsp;&nbsp;&nbsp;&nbsp;上面代码的另一个细节是除法可以是除以简并三角形为零，即fγ = 0。要么对浮点错误条件进行适当的解释，要么就需要进行另一项测试
#### 9.1.3 透视校正插值
&nbsp;&nbsp;&nbsp;&nbsp;在插值数量时，如纹理坐标或3D位置，需要在3D三角形上线性变化，在实现正确的视角方面有一些微妙之处。我们将使用纹理坐标作为一个例子,这是一个角度校正很重要的量，但同样的考虑也适用于3D空间中线性很重要的任何属性。
&nbsp;&nbsp;&nbsp;&nbsp;事情不是这么简单的原因是，在屏幕空间中插入纹理坐标会导致错误的图像，如图9.7中所示的网格纹理。因为透视中的物体会随着与观看者距离的增加而变小，所以在3D中均匀间隔的线条在2D图像空间中应该会压缩。为了实现这一点，需要对纹理坐标进行更仔细的插值
&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过插值(u, v)坐标来实现三角形上的纹理映射，修改9.1.2节的栅格化方法，但这导致了图9.7右侧所示的问题。如果屏幕空间重心坐标如以下光栅化代码所示，三角形也会出现类似的问题:
~~~
for all x do
    for all y do
        compute (α, β, γ) for (x, y)
        if α ∈ (0, 1) and β ∈ (0, 1) and γ ∈ (0, 1) then
            t = αt0 + βt1 + γt2
            drawpixel (x, y) with color texture(t) for a solid texture
            or with texture(β, γ) for a 2D texture
~~~
&nbsp;&nbsp;&nbsp;&nbsp;这段代码将生成图像，但有一个问题。为了解开这个基本问题，让我们考虑从世界空间q到齐次点r再到齐次点s的过程
$$
\begin{bmatrix}x_q\\ y_q\\ z_q \\1 \end{bmatrix}
\stackrel{变换}{\rightarrow}
\begin{bmatrix}x_r\\ y_r\\ z_r \\h_r \end{bmatrix}
\stackrel{归一化}{\rightarrow}
\begin{bmatrix}x_r/h_r\\ y_r/h_r\\ z_r/h_r\\1 \end{bmatrix}\equiv
\begin{bmatrix}x_s\\ y_s\\ z_s\\ 1 \end{bmatrix}
$$
&nbsp;&nbsp;&nbsp;&nbsp;纹理坐标插值问题的最简单形式是，当我们有与两点q和q相关的纹理坐标(u, v)时，我们需要在图像中沿着s和s之间的直线生成纹理坐标。如果世界空间点q位于q和q之间的直线上，投影到s和s之间的屏幕空间点s，那么这两个点应该具有相同的纹理坐标
&nbsp;&nbsp;&nbsp;&nbsp;由上述算法体现的na¨avve屏幕空间方法说，在点s = s+α(s−s)处，我们应该使用纹理坐标us+α(us−us)和vs +α(vs−vs)。这是不正确的，因为转换为s的世界空间点q不是q + α(q−q)。
&nbsp;&nbsp;&nbsp;&nbsp;但是，我们从8.4节知道q和q之间的线段上的点最终会在an之间的线段上的某个地方结束,
&nbsp;&nbsp;&nbsp;&nbsp;事实上，在那一节中我们已经演示过了
$$
q+t(Q-q)\rightarrow s+\alpha(S-s).
$$
&nbsp;&nbsp;&nbsp;&nbsp;插值参数t和a是不一样的，但我们可以用其中一个来计算:
$$
t(a)=\frac{w_ra}{w_R+a(w_r-w_R)},a(t)=\frac{w_Rt}{w_r+t(w_R-w_r)}
$$
&nbsp;&nbsp;&nbsp;&nbsp;这些方程为屏幕空间插值的想法提供了一种可能的修正。
&nbsp;&nbsp;&nbsp;&nbsp;为了得到屏幕空间点s' = s + a(s -s)的纹理坐标，计算u'， = ug +t(a)(us - us)和v'， = us +t(a)(us - vs)。这是点q'映射到s'的坐标，所以这是可行的。然而，为每个片段求t(a)的值很慢，有一种更简单的方法。
&nbsp;&nbsp;&nbsp;&nbsp;关键的观察结果是，因为我们知道，透视变换保留了直线和平面，所以在三角形之间线性插值任何属性是安全的，但前提是它们要与点一起通过透视变换(图9.8)。为了获得几何上的直观感受，我们可以降低维度，这样我们就有了齐次的点(Cr, yr, w，)和被插值的单个属性u。属性u应该是rr和yr的线性函数，所以如果我们把u画成高度场(Tr, yr)，结果是一个平面。现在，如果我们认为u是第三个空间坐标(称它为u，以强调它与其他空间坐标相同)，并通过透视转换发送整个3D齐次点(Tr, yr, ur, w)，结果(s, ys, us)仍然生成位于平面上的点。平面内会有一些翘曲，但平面保持平坦。这意味着我们是(Tg, ys)的线性函数，也就是说，我们可以在任何位置通过基于坐标(Ts, ys)的线性插值来计算我们。
&nbsp;&nbsp;&nbsp;&nbsp;回到完整的问题，我们需要插值纹理坐标(u, u)，它是世界空间坐标(Tq, yq,q)的线性函数。在将点转换到屏幕空间，并添加纹理坐标，就像它们是额外的坐标一样，我们有
$$
\begin{bmatrix}u\\ v\\ 1\\ x_r\\ y_r\\ z_r\\ w_r \end{bmatrix}
\stackrel{归一化}{\rightarrow}
\begin{bmatrix}u/w_r\\ v/w_r\\ 1/w_r\\ x_r/w_r=x_s\\ y_r/w_r=y_s\\ z_r/w_r=z_s\\ 1 \end{bmatrix}
$$
&nbsp;&nbsp;&nbsp;&nbsp;上一段的实际含义是，我们可以根据(xs, ys)的值(包括z缓冲区中使用的zs值)来插值所有这些量。na¨evve方法的问题很简单，我们在插值选择不一致的组件——只要涉及的数量来自透视分割之前或全部来自透视分割之后，就没问题。
剩下的一个问题是(u/wr, v/wr)对于查找纹理数据不是直接有用的;我们需要(u, v)。这解释了我们插入(9.3)的额外参数的目的，它的值总是1:一旦我们有u/wr, v/wr和1/wr，我们可以很容易地通过除法恢复(u, v)
&nbsp;&nbsp;&nbsp;&nbsp;为了验证这些都是正确的，让我们检查插值的数量.屏幕空间中的1/wr确实产生了世界空间中插值的wr的倒数。要确认这是真的，请确认(练习2)
$$
\frac{1}{w_r}+a(t)(\frac{1}{w_R}-\frac{1}{w_r})=\frac{1}{w'_r}=\frac{1}{w_r+t(w_R-w_r)}
$$
&nbsp;&nbsp;&nbsp;&nbsp;记住α(t)和t由公式9.2联系起来.
&nbsp;&nbsp;&nbsp;&nbsp;这种在转换空间中线性插值1/wr的能力允许我们正确地纹理三角形。我们可以使用这些事实来修改扫描转换代码的三个点ti = (xi, yi, zi, wi)，这三个点已经通过了观察矩阵，但没有均匀化，完成了纹理坐标ti = (ui, vi):
~~~
    for all xs do
        for all ys do
            compute (α, β, γ) for (xs, ys)
            if (α ∈ [0, 1] and β ∈ [0, 1] and γ ∈ [0, 1]) then
                us = α(u0/w0) + β(u1/w1) + γ(u2/w2)
                vs = α(v0/w0) + β(v1/w1) + γ(v2/w2)
                1s = α(1/w0) + β(1/w1) + γ(1/w2)
                u = us/1s
                v = vs/1s
                drawpixel (xs, ys) with color texture(u, v)
~~~
&nbsp;&nbsp;&nbsp;&nbsp;当然，这个伪代码中出现的许多表达式都是在fo循环之外预先计算的
&nbsp;&nbsp;&nbsp;&nbsp;在实践中，现代系统以透视正确的方式插值所有属性，除非特别要求一些其他方法
#### 9.1.4 裁剪
&nbsp;&nbsp;&nbsp;&nbsp;简单地将原语转换到屏幕空间并将其栅格化是不行的完全是工作本身。这是因为在视图卷之外的原语特别是眼睛后面的原语最终会被栅格化，导致不正确的结果。例如，考虑如图所示的三角形图9.9。两个顶点在视图体积中，但第三个顶点在眼睛后面。投影变换将这个顶点映射到后面一个无意义的位置远面，如果允许发生这种情况，三角形的栅格化将会是正确的。因此，在栅格化之前必须先进行剪切操作这样就去掉了可能延伸到眼睛后面的部分原体。
&nbsp;&nbsp;&nbsp;&nbsp;裁剪是图形学中常见的操作，每当一个几何图形都需要裁剪实体“削减”。例如，如果你在x = 0的平面上夹一个三角形，平面将三角形切成两部分，如果x坐标的符号顶点并不都是一样的。在大多数裁剪的应用中，裁剪的部分位于平面“错误”一侧的三角形被丢弃。此操作为单次操作平面如图9.10所示。
&nbsp;&nbsp;&nbsp;&nbsp;在为栅格化做准备的裁剪中，“错误”的一面是外面的一面视图体积。去掉视图外的所有几何图形总是安全的体积——也就是在体积的所有六个面上裁剪——但有很多系统只在附近的飞机上剪接就设法逃脱了。
&nbsp;&nbsp;&nbsp;&nbsp;本节讨论剪辑模块的基本实现。那些对实现工业速度的快船感兴趣的人应该看这本书布林在本章末尾的注释中提到过。
&nbsp;&nbsp;&nbsp;&nbsp;实现剪辑的两种最常见的方法是
1. 在世界坐标中使用六个平面来连接截断视图金字塔,
2. 在四维变换空间中，在齐次划分之前。
&nbsp;&nbsp;&nbsp;&nbsp;这两种可能性都可以有效地实现(J. Blinn, 1996)
~~~
for each of six planes do
    if (triangle entirely outside of plane) then
        break (triangle is not visible)
    else if triangle spans plane then
        clip triangle
        if (quadrilateral is left) then
            break into two triangles
~~~
##### 在变换前裁剪（选项1）
&nbsp;&nbsp;&nbsp;&nbsp;选型1能很直观的应用。唯一的问题是，6个平面方程在哪里？因为与在单幅图像中的渲染方程一样，我们不需要有效的计算他们。出于这个原因，我们可以将图7.12所示的转换进行反转，并将其应用到转换后的视图卷的八个顶点上
$$
\begin{aligned}
(x, y, z) = &(l, b, n)\\
&(r, b, n)\\
&(l, t, n)\\
&(r, t, n)\\
&(l, b, f)\\
&(r, b, f)\\
&(l, t, f)\\
&(r, t, f)\\
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;平面方程可以从这里推导出来。或者，我们可以使用矢量几何直接从查看参数获得平面
##### 齐次坐标中的裁剪(选项2)
&nbsp;&nbsp;&nbsp;&nbsp;令人惊讶的是，通常实现的选项是在除法之前裁剪齐次坐标。这里，视图体积是4D，它的边界是3 d卷(超平面)。这些基于“增大化现实”技术:
$$
\begin{aligned}
−x + lw &= 0,\\
x − rw &= 0,\\
−y + bw &= 0,\\
y − tw &= 0,\\
−z + nw &= 0,\\
z − fw &= 0
\end{aligned}
$$
&nbsp;&nbsp;&nbsp;&nbsp;这些平面非常简单，所以效率比选项1好。它们仍然可以通过将视图体积[l, r] × [b, t] × [f,n]转换为来改进[0, 1] 3。事实证明，三角形的裁剪并不比3D复杂多少
##### 接在一个平面上
无论我们选择哪一种选择，我们都必须与飞机相撞。回想一下第2.7.5节，通过点q，法线为n的平面的隐式方程为
$$
f(p) = n\cdot (p − q)=0
$$
&nbsp;&nbsp;&nbsp;&nbsp;常被写为：
$$
f(p) = n \cdot p + D = 0. \tag{9.5}
$$
&nbsp;&nbsp;&nbsp;&nbsp;有趣的是，这个方程不仅描述了3D平面，还描述了2D直线和4D平面的体积模拟。所有这些实体在其相应的维度中通常被称为平面。

&nbsp;&nbsp;&nbsp;&nbsp;如果我们有a点和b点之间的线段，我们可以使用第12.4.3节描述的BSP树程序中切割3D三角形边缘的技术在平面上“剪辑”它。在这里，通过检查f(a)和f(b)是否有不同的符号，来测试点a和点b是否在平面f(p)=0的相对两侧。通常，f(p) < 0定义为在平面内，f(p) > 0在平面外。如果平面分裂了直线，那么我们可以通过代入参数直线的方程来求解交点
$$
p = a + t(b − a)
$$
&nbsp;&nbsp;&nbsp;&nbsp;(9.5)的f(p)=0平面。这个返回
$$
n \cdot  (a + t(b − a)) + D = 0
$$
&nbsp;&nbsp;&nbsp;&nbsp;求解t
$$
t= \frac{ n \cdot a + D}{n \cdot  (a − b)}
$$
后我们可以找到交点，并“缩短”这条线。
&nbsp;&nbsp;&nbsp;&nbsp;要截取一个三角形，我们可以再次按照12.4.3节的方法生成一个或两个三角形

***
### 9.2 光栅化前后的操作
&nbsp;&nbsp;&nbsp;&nbsp;在一个元素可以栅格化之前，定义它的顶点必须在屏幕上坐标，颜色或其他应该被插值的属性跨越原始必须是已知的。准备这些数据是管道顶点处理阶段的工作。在此阶段，将转换传入顶点通过建模、查看和投影转换，将它们映射到它们在屏幕空间中的原始坐标(回想一下，位置是在这里测量的)以像素为单位)。同时，其他信息，如颜色、表面法线，或纹理坐标，根据需要进行转换;我们将讨论这些
下面示例中的附加属性。
&nbsp;&nbsp;&nbsp;&nbsp;栅格化后，进一步处理，计算出颜色和深度为每一个片段。这一处理过程可以非常简单，只需通过一种插值的颜色，并使用光栅化器计算出的深度;也可能涉及到复杂的阴影操作。最后，混合阶段结合由重叠每个像素的原语(可能是几个)生成的片段来计算最终的颜色。最常见的混合方法是选择深度最小的片段的颜色(最接近眼睛)。
&nbsp;&nbsp;&nbsp;&nbsp;不同阶段的目的可以用例子最好地说明。
#### 9.2.1简单二维绘图
&nbsp;&nbsp;&nbsp;&nbsp;最简单的管道在顶点或片段阶段不做任何事情，在混合阶段，每个片段的颜色只是覆盖前一个片段的值。应用程序直接在像素坐标中提供原语，光栅化器完成所有工作。这种基本的安排是许多用于绘制用户界面、图表和其他2D内容的简单的老式api的本质。通过为每个原语的所有顶点指定相同的颜色，可以绘制纯色形状，我们的模型管道还支持使用插值平滑地改变颜色。
#### 9.2.2一个最小的3D管道
&nbsp;&nbsp;&nbsp;&nbsp;要在3D中绘制物体，对2D绘图管道的唯一更改是一个单一矩阵转换:顶点处理阶段将传入顶点位置乘以建模、相机、投影和视口矩阵的乘积，生成屏幕空间三角形，然后以与在2D中直接指定相同的方式绘制它们。
&nbsp;&nbsp;&nbsp;&nbsp;最小3D管道的一个问题是，为了获得正确的遮挡关系——使较近的物体在较远的物体前面——原始物体必须按前后顺序绘制。这被称为画家去除隐藏表面的算法，类似于先画一幅画的背景，然后在它上面画前景。画家的算法是一种去除隐藏表面的完美有效的方法，但它有几个缺点。
它不能处理彼此相交的三角形，因为没有正确的顺序来绘制它们。类似地，几个三角形，即使它们不相交，仍然可以排列成一个遮挡循环，如图9.11所示，这是另一个前后顺序不存在的情况。最重要的是，按深度排序基元很慢，特别是对于大型场景，并且扰乱了使对象顺序渲染如此快速的有效数据流。图9.12显示了当对象没有按深度排序时，这个过程的结果。
#### 9.2.3 使用z缓冲隐藏表面
&nbsp;&nbsp;&nbsp;&nbsp;在实际应用中，画家算法很少使用;取而代之的是一种简单有效的隐曲面去除算法，称为z缓冲区算法。这个方法非常简单:在每个像素点上，我们跟踪到目前为止绘制的最近表面的距离，然后丢弃比这个距离更远的碎片。最近的距离是通过为每个像素分配一个额外的值来存储的，除了红色、绿色和蓝色的颜色值之外，这被称为深度或z值。深度缓冲区或z-缓冲区是深度值网格的名称。
&nbsp;&nbsp;&nbsp;&nbsp;z-buffer算法在片段混合阶段实现，通过将每个片段的深度与存储z-buffer中的当前值进行比较。如果片段的深度更接近，它的颜色和深度值都会覆盖当前在颜色和深度缓冲区中的值。如果碎片的深度较远，它就会被丢弃。为了确保第一个片段将通过深度测试，z缓冲区被初始化为最大深度(远平面的深度)。无论绘制表面的顺序如何，相同的碎片将赢得深度测试，图像将是相同的。
&nbsp;&nbsp;&nbsp;&nbsp;z缓冲区算法要求每个片段都有一个深度。这可以通过插值z坐标作为顶点属性来实现，就像插值颜色或其他属性一样。
&nbsp;&nbsp;&nbsp;&nbsp;z缓冲区是在对象顺序渲染中处理隐藏表面的一种简单而实用的方法，它是迄今为止的主要方法。它比几何方法要简单得多，几何方法将表面切割成可以按深度排序的块，因为它避免了解决任何不需要解决的问题。深度顺序只需要在像素的位置确定，这就是z-buffer所做的。它得到了硬件图形管道普遍支持，也是软件管道最常用的方法。图9.13和9.14显示了示例结果。
##### 精度问题
来实现，就像插值颜色或其他属性一样。
&nbsp;&nbsp;&nbsp;&nbsp;实际上，存储在缓冲区中的z值是非负整数。这比真浮点更可取，因为z缓冲区所需的快速内存有点昂贵，值得保持在最小值。
来实现，就像插值颜色或其他属性一样。
&nbsp;&nbsp;&nbsp;&nbsp;使用整数可能会导致一些精度问题。如果我们使用一个包含B个值{0,1，…，B−1}时，我们可以将0映射到近剪切平面z = n，将B−1映射到远剪切平面z = f。注意，对于这个讨论，我们假设z、n和f是正的。这将导致与否定情况相同的结果，但论证的细节更容易理解。一个深度Δz = (f−n)/B的“桶”。如果内存不重要，我们就不会使用整数z缓冲区，因此使B尽可能小是有用的。
&nbsp;&nbsp;&nbsp;&nbsp;如果分配b位来存储z值，那么b = 2b。我们需要足够的比特来确保任何三角形前面的另一个三角形将其深度映射到不同的深度箱。
&nbsp;&nbsp;&nbsp;&nbsp;例如，如果您正在渲染一个场景，其中三角形之间的间隔至少一米，那么Δz < 1应该生成没有工件的图像
&nbsp;&nbsp;&nbsp;&nbsp;有两种方法使Δz变小:将n和f移近或增加b。如果b是固定的，因为它可能在api中或在特定的硬件平台上，调整n和f是唯一的选择。
&nbsp;&nbsp;&nbsp;&nbsp;当透视时，z缓冲区的精度必须非常小心地处理创建图像。上面的值Δz是在透视分割之后使用的。回顾8.3节，视角划分的结果是
$$
Z = n + f−\frac{fn}{zw}
$$
&nbsp;&nbsp;&nbsp;&nbsp;实际的bin深度与zw(世界深度)相关，而不是与z(后透视划分深度)相关。我们可以通过对两者求导来近似箱子的大小方面:
$$
\Delta z \approx \frac{fn\Delta z_w}{z_w^2}
$$
&nbsp;&nbsp;&nbsp;&nbsp;存储器的大小因深度而异。世界空间中的垃圾箱大小为
$$
\Delta z_w \approx \frac{z_w^2\Delta z}{fn}
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，数量Δz与前面讨论的一样。最大的箱子是用来放的Z=f，其中
$$
\Delta z_w^max \approx \frac{f\Delta z}{n}
$$
&nbsp;&nbsp;&nbsp;&nbsp;请注意选择n = 0，如果我们不想丢失对象，这是一个自然的选择在眼前，会造成一个无限大的箱子——一个非常糟糕的情况。来使Δzmaxw尽可能小，我们要最小化f，最大化n，因此，仔细选择n和f总是很重要的
#### 9.2.4 每顶点渲染
&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，将三角形发送到管道的应用程序负责设置颜色;光栅化器只是插入颜色，它们直接被写出来输出图像。对于某些应用程序，这就足够了，但在许多情况下，我们希望3D对象被画上阴影，使用与我们在第4章中使用的图像顺序渲染相同的照明设备。回想一下，这些等式需要一个光的方向，一个眼睛的方向和一个表面法线来计算着色
&nbsp;&nbsp;&nbsp;&nbsp;表面的颜色处理阴影计算的一种方法是在顶点上执行它们阶段。应用程序提供顶点的法向量和位置灯的颜色是单独提供的(它们不会在表面上变化所以它们不需要为每个顶点指定)。对于每个顶点，根据相机、灯光和顶点的位置计算到观看者的方向和到每个光的方向。计算所需的着色方程来计算颜色，然后将其作为顶点颜色传递给光栅化器。Pervertex shading有时被称为Gouraud shading。
&nbsp;&nbsp;&nbsp;&nbsp;要做的一个决定是在做阴影计算的坐标系中。世界空间或眼睛空间都是不错的选择。当在世界空间中观察时，选择一个标准正交的坐标系是很重要的，因为阴影方程依赖于向量之间的角度，而这并没有被建模转换中经常使用的非均匀比例尺或透视投影(通常用于向规范视图体的投影)等操作所保留。眼空间的阴影有一个优点，我们不需要跟踪相机的位置，因为相机总是在眼空间的原点，在透视投影中，或者在正投影中，视图的方向总是+Z。
&nbsp;&nbsp;&nbsp;&nbsp;逐顶点阴影的缺点是，它不能在阴影中生成任何比用于绘制曲面的基元更小的细节，因为它只为每个顶点计算一次阴影，而从不在顶点之间计算阴影。例如，如果一个房间的地板是用两个大三角形绘制的，并且在房间中间有一个光源照射，那么阴影只会在房间的角落评估，插值的值很可能在中心太暗。另外，用高光遮蔽的曲面必须使用足够小的基元来绘制，以便高光可以被解析。
&nbsp;&nbsp;&nbsp;&nbsp;图9.15显示了我们用逐顶点着色绘制的两个球体。
#### 9.2.5 每片段渲染
&nbsp;&nbsp;&nbsp;&nbsp;为了避免与逐顶点着色相关的插值工件，我们可以这样做在片段阶段，通过在插入插值之后执行着色计算来避免插入颜色。在每个片段的阴影，相同的阴影对方程进行计算，但是对每个片段使用相互关联的向量进行计算，而不是对每个顶点使用来自应用程序的向量进行计算。
&nbsp;&nbsp;&nbsp;&nbsp;在每段阴影中，阴影所需的几何信息为通过光栅化作为属性，所以顶点阶段必须协调用片段阶段适当地准备数据。一种方法是对眼空间表面法线和眼空间顶点位置进行三元插值然后可以像在逐顶点着色中那样使用。
&nbsp;&nbsp;&nbsp;&nbsp;图9.16显示了我们用每个片段着色绘制的两个球体。
#### 9.2.6 纹理映射
&nbsp;&nbsp;&nbsp;&nbsp;纹理(在第11章中讨论)是用来给表面添加额外细节的图像，否则看起来会太均匀和人造。这个想法很简单:每次计算阴影时，我们从纹理中读取一个用于阴影计算的值——例如漫反射颜色——而不是使用附加到被渲染的几何图形上的属性值。这个操作被称为纹理查找:着色代码指定纹理坐标，纹理域中的一个点，纹理映射系统在纹理图像中找到该点的值并返回它。然后在阴影计算中使用纹理值。
&nbsp;&nbsp;&nbsp;&nbsp;定义纹理坐标最常见的方法是简单地使纹理坐标成为另一个顶点属性。每个原语都知道它在纹理中的位置。
#### 9.2.7 着色频率
&nbsp;&nbsp;&nbsp;&nbsp;在哪里进行阴影计算取决于颜色变化的速度——计算细节的比例。具有大规模特征的阴影，如曲面上的漫反射阴影，可以相当不频繁地计算然后插值:它可以用较低的阴影频率计算。产生小范围特征的阴影，如尖锐的高光或详细的纹理，需要在高阴影频率下进行评估。对于需要在图像中看起来锐利和清晰的细节，阴影频率需要每个像素至少有一个阴影样本。
&nbsp;&nbsp;&nbsp;&nbsp;因此，即使定义原语的顶点相隔许多像素，也可以安全地在顶点阶段计算大规模效果。需要高着色频率的效果也可以在顶点阶段计算，只要顶点在图像中紧密相连;或者，当原语大于一个像素时，可以在片段阶段计算它们。
&nbsp;&nbsp;&nbsp;&nbsp;例如，在电脑游戏中使用的硬件管道，通常使用覆盖几个像素的原语以确保高效率，通常每个片段进行大多数阴影计算。另一方面，PhotoRealistic RenderMan系统在每个顶点进行所有的阴影计算，在第一次细分或切丁后，所有的表面都被称为微多边形的小四边形，大约像素大小。由于原语较小，该系统中的逐顶点着色实现了较高的着色频率，适合于详细的着色。
### 9.3 简单的反走样
&nbsp;&nbsp;&nbsp;&nbsp;就像光线追踪一样，如果我们对每个像素是否在原语中进行全有或全无的确定，栅格化将产生锯齿线和三角形边缘。事实上，本章描述的简单三角形栅格化算法生成的片段集(有时称为标准或别名栅格化)与通过射线跟踪器将一条射线发送到每个像素中心而映射到三角形的像素集完全相同。
同样在射线追踪中，解决方案是允许像素部分被原语覆盖(Crow, 1978)。在实践中，这种模糊形式有助于提高视觉质量，特别是在动画中。如图9.17的最上面一行所示。
&nbsp;&nbsp;&nbsp;&nbsp;在栅格化应用中，有许多不同的抗锯齿方法。就像使用射线跟踪器一样，我们可以通过将每个像素值设置为属于该像素的正方形区域上图像的平均颜色来生成反锯齿图像，这种方法称为框过滤。这意味着我们必须认为所有可绘制实体都具有明确定义的区域。例如，图9.17中的直线可以被认为是一个近似于一个像素宽的矩形。
&nbsp;&nbsp;&nbsp;&nbsp;实现盒过滤器抗混叠最简单的方法是通过超采样:创建分辨率非常高的图像，然后向下采样。例如，如果我们的目标是一条宽度为1.2像素的256 x 256像素的直线图像，我们可以在1024 x 1024的屏幕上对宽度为4.8像素的直线矩形版本进行光栅化，然后对4 x 4组像素进行平均，以获得“缩小”图像中256 x 256像素中的每个像素的颜色。这是实际的盒过滤图像的近似值，但当物体相对于像素之间的距离不是非常小时，效果很好。
&nbsp;&nbsp;&nbsp;&nbsp;然而，超抽样是相当昂贵的。因为导致混叠的非常尖锐的边缘通常是由原语的边缘引起的，而不是原语中阴影的突然变化，因此一种广泛使用的优化是以比阴影更高的速率采样可见性。如果每个像素内的几个点存储关于覆盖率和深度的信息，即使只计算一种颜色也可以实现非常好的抗锯齿。在RenderMan等使用逐顶点着色的系统中，这是通过高分辨率光栅化实现的:因为shadi，这样做的成本不高

***
### 9.4 提高性能的剔除
&nbsp;&nbsp;&nbsp;&nbsp;对象顺序渲染的优点是，它需要在场景中的所有几何图形上进行一次单一的传递，这也是复杂场景的弱点。例如，在一个整个城市的模型中，在任何给定的时间只有少数的建筑可能是可见的。一个正确的图像可以通过绘制场景中的所有基本元素来获得，但大量的努力将浪费在处理可见建筑后面的几何图形上，或在观看者后面，因此无助于最终的图像。
&nbsp;&nbsp;&nbsp;&nbsp;识别和丢弃不可见的几何图形以节省处理它的时间称为剔除。三种通常实现的剔除策略(通常是串联使用的)是
+ 视图体剔除——删除视图体之外的几何图形;
+ 遮挡剔除——去除可能在视图体积内但被其他更靠近相机的几何图形遮蔽或遮挡的几何图形;
+ 背面剔除——去除远离镜头的原始生物。
&nbsp;&nbsp;&nbsp;&nbsp;我们将简要讨论视图体积剔除和背面剔除，但高性能系统中的剔除是一个复杂的主题;参见Akenine-Möller, Haines和Hoffman(2008)获得关于闭塞剔除的完整讨论和信息。
#### 9.4.1视图卷剔除
&nbsp;&nbsp;&nbsp;&nbsp;当整个原语位于视图卷之外时，它可以被剔除，因为它在栅格化时不会产生片段。如果我们可以通过快速测试剔除许多原语，我们可能会显著加快绘图的速度。另一方面，单独测试原语以确定需要绘制哪些原语可能比让光栅化器消除它们花费更多。
&nbsp;&nbsp;&nbsp;&nbsp;视图卷剔除，也称为视图截锥剔除，在许多三角形被分组到一个具有关联边界卷的对象时特别有用。如果边界卷位于视图卷之外，那么组成对象的所有三角形也位于视图卷之外。例如，如果我们有1000个三角形以一个圆心为c，半径为r的球面为界，我们可以检查这个球面是否在剪切平面之外，
$$
(p-a)\cdot n = 0,
$$
&nbsp;&nbsp;&nbsp;&nbsp;a是平面上的一个点，p是一个变量。这等价于检查从球面c到平面的带符号距离是否大于+r。这相当于检测
$$
\frac{(c-a)\cdot n}{||n||}>r
$$
&nbsp;&nbsp;&nbsp;&nbsp;注意，即使在所有三角形都位于平面外的情况下，球面也可能与平面重叠。因此，这是一个保守检验。测试的保守程度取决于球体与物体的边界。
&nbsp;&nbsp;&nbsp;&nbsp;如果场景是在第12章描述的空间数据结构中组织的，那么同样的思想也可以分层应用。

#### 9.4.2隐面消除
&nbsp;&nbsp;&nbsp;&nbsp;当多边形模型是封闭的，即它们绑定一个没有孔的封闭空间时，通常假设它们具有第5章中讨论的面向外的法向量。对于这样的模型，面向眼睛的多边形肯定会被面向眼睛的多边形透支。因此，这些多边形可以在管道开始之前被剔除。


***
### FAQ
+ 我经常看到关于剪辑的详细讨论，它比本章所描述的要复杂得多。这是怎么回事?
本章中描述的裁剪是有效的，但缺乏工业强度裁剪器所具有的优化。这些优化在Blinn在本章注释中列出的权威著作中有详细讨论。
+ 非三角形的多边形如何栅格化?
这些可以直接逐行扫描，也可以分解成三角形。后者似乎是更受欢迎的技术。
+ 反走样总是一个更好的选择吗?
不。有些图像在没有抗锯齿的情况下看起来更清晰。许多程序使用无反锯齿的“屏幕字体”，因为它们更容易阅读。
+ 我的API文档谈到了“场景图”和“矩阵栈”。这些是图形管道的一部分吗?
当然，图形管道在设计时就考虑到了这些，而我们是否将其定义为管道的一部分则取决于个人喜好。这本书把他们的讨论推迟到第12章。
+ 均匀距离z缓冲器是否比包含透视矩阵非线性的标准z缓冲器更好?
视情况而定。非线性的一个“特征”是z缓冲区在眼睛附近的分辨率更高，而在远处的分辨率更低。如果使用细节级系统，那么距离中的几何图形就会更粗糙，z缓冲区的“不公平”可能是件好事。
+ 软件z缓冲区有用吗?
是的。大多数使用3D计算机图形的电影都使用了皮克斯(Cook,Carpenter，&Catmull, 1987)开发的z缓冲软件的变体。

***
### 笔记
&nbsp;&nbsp;&nbsp;&nbsp;《Jim Blinn的角落: 图形管线之旅》(J. Blinn, 1996)是一本关于设计图形管道的好书。在<<3D游戏引擎设计>>(Eberly, 2000)和<<实时渲染>>(Akenine-Moller et al. 2008)中有许多关于管道和筛选的细节.

***
### 练习题
1. 假设在透视变换中，我们有n = 1 f = 2。
在什么情况下，我们会有一个“反转”，即透视变换前后的顶点从眼睛的前面翻转到后面，或者反之亦然?
2. 是否有理由在透视划分之后不插入x和y(参见图11.2，第3阶段)?
3. 推导出0 <m <1时端点处颜色的中点画线算法的增量形式。
4. 修改三角形绘制算法，使其为经过(r, y) =(-1， -1)的三角形边缘上的点精确绘制一个像素。
5. 假设你正在为飞行模拟设计一个整数z缓冲区，其中所有的物体都至少有一米厚，离观察者的距离不会超过4米，甚至可能远至100公里。z缓冲区中需要多少位来确保没有可见性错误?假设可见性误差只与观看者附近的距离有关，即小于100米的距离。在这种情况下需要多少位?